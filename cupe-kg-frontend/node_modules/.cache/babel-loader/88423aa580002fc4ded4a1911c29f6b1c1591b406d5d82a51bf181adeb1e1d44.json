{"ast":null,"code":"// cupe-kg-frontend/src/utils/enhancedRoutePlanner.js\n// FIXED VERSION - Replace your entire enhancedRoutePlanner.js with this\n\nexport class UltraAccurateRoutePlanner {\n  constructor(locations, routes) {\n    this.locations = locations || [];\n    this.routes = routes || [];\n\n    // Real distance matrix (in km) between major Indian cities\n    this.realDistanceMatrix = {\n      'delhi': {\n        'jaipur': 280,\n        'agra': 233,\n        'varanasi': 821,\n        'amritsar': 460,\n        'hampi': 1483,\n        'udaipur': 421,\n        'khajuraho': 620,\n        'bodh-gaya': 1105\n      },\n      'jaipur': {\n        'delhi': 280,\n        'udaipur': 393,\n        'taj-mahal': 240,\n        'ajanta': 739\n      },\n      'taj-mahal': {\n        'delhi': 233,\n        'jaipur': 240,\n        'khajuraho': 295,\n        'varanasi': 605\n      },\n      'varanasi': {\n        'delhi': 821,\n        'bodh-gaya': 250,\n        'khajuraho': 298,\n        'kolkata': 679,\n        'agra': 605\n      },\n      'bodh-gaya': {\n        'varanasi': 250,\n        'delhi': 1105,\n        'kolkata': 495,\n        'patna': 135\n      },\n      'hampi': {\n        'delhi': 1483,\n        'madurai': 440\n      },\n      'madurai': {\n        'hampi': 440,\n        'chennai': 462,\n        'bangalore': 460,\n        'kochi': 257\n      },\n      'amritsar': {\n        'delhi': 460,\n        'chandigarh': 230,\n        'shimla': 350\n      },\n      'udaipur': {\n        'jaipur': 393,\n        'delhi': 421,\n        'mumbai': 734,\n        'ajanta': 451\n      },\n      'konark': {\n        'bhubaneswar': 65,\n        'kolkata': 380,\n        'delhi': 1108\n      },\n      'ajanta': {\n        'ellora': 95,\n        'mumbai': 440,\n        'pune': 240,\n        'udaipur': 451\n      },\n      'ellora': {\n        'ajanta': 95,\n        'mumbai': 380,\n        'pune': 220\n      }\n    };\n\n    // Transportation costs (INR per km)\n    this.transportationCosts = {\n      'flight': 3.5,\n      'train': 0.75,\n      'bus': 0.45,\n      'car': 12\n    };\n\n    // Accommodation costs by city (per night)\n    this.accommodationCosts = {\n      'delhi': {\n        low: 1200,\n        medium: 3500,\n        high: 8500\n      },\n      'jaipur': {\n        low: 800,\n        medium: 2500,\n        high: 6500\n      },\n      'taj-mahal': {\n        low: 900,\n        medium: 2800,\n        high: 7000\n      },\n      'varanasi': {\n        low: 600,\n        medium: 1800,\n        high: 4500\n      },\n      'amritsar': {\n        low: 700,\n        medium: 2000,\n        high: 5000\n      },\n      'udaipur': {\n        low: 1000,\n        medium: 3200,\n        high: 8000\n      },\n      'hampi': {\n        low: 500,\n        medium: 1500,\n        high: 3500\n      },\n      'madurai': {\n        low: 600,\n        medium: 1800,\n        high: 4000\n      },\n      'bodh-gaya': {\n        low: 400,\n        medium: 1200,\n        high: 2800\n      },\n      'konark': {\n        low: 600,\n        medium: 1600,\n        high: 3500\n      },\n      'mahabalipuram': {\n        low: 800,\n        medium: 2200,\n        high: 5500\n      },\n      'ajanta': {\n        low: 600,\n        medium: 1600,\n        high: 3800\n      },\n      'ellora': {\n        low: 600,\n        medium: 1600,\n        high: 3800\n      },\n      'khajuraho': {\n        low: 700,\n        medium: 2000,\n        high: 4500\n      }\n    };\n\n    // Weather and seasonal data\n    this.seasonalData = {\n      'winter': {\n        months: ['Oct', 'Nov', 'Dec', 'Jan', 'Feb', 'Mar'],\n        bestRegions: ['north', 'central', 'west', 'south'],\n        temperature: {\n          min: 10,\n          max: 25\n        },\n        rainfall: 'minimal'\n      },\n      'summer': {\n        months: ['Apr', 'May', 'Jun'],\n        bestRegions: ['hills', 'north-east'],\n        avoidRegions: ['rajasthan', 'central'],\n        temperature: {\n          min: 25,\n          max: 45\n        },\n        rainfall: 'none'\n      },\n      'monsoon': {\n        months: ['Jul', 'Aug', 'Sep'],\n        bestRegions: ['western-ghats', 'caves'],\n        temperature: {\n          min: 20,\n          max: 30\n        },\n        rainfall: 'heavy'\n      }\n    };\n  }\n\n  // Main route creation function\n  createUltraAccurateRoute(preferences) {\n    console.log('Creating ultra-accurate route with preferences:', preferences);\n    const {\n      interests = [],\n      max_travel_days = 7,\n      budget_range = 'medium',\n      start_location = null,\n      transport_mode = 'car',\n      max_distance_km = 500\n    } = preferences;\n\n    // Step 1: Filter locations by interests\n    let candidateLocations = this.filterLocationsByInterests(interests);\n    console.log('Candidate locations found:', candidateLocations.length);\n    if (candidateLocations.length === 0) {\n      throw new Error('No locations found matching your interests');\n    }\n\n    // Step 2: Filter locations by distance from start location\n    if (start_location && max_distance_km) {\n      candidateLocations = this.filterLocationsByDistance(candidateLocations, start_location, max_distance_km);\n      console.log(`Locations within ${max_distance_km}km:`, candidateLocations.length);\n      if (candidateLocations.length === 0) {\n        throw new Error(`No locations found within ${max_distance_km}km of your starting point. Try increasing the distance limit.`);\n      }\n    }\n\n    // Step 3: Create optimized path\n    const optimizedPath = this.optimizePath(candidateLocations, start_location, max_travel_days, max_distance_km);\n    console.log('Optimized path created:', optimizedPath.length, 'locations');\n    if (optimizedPath.length === 0) {\n      throw new Error('Could not create an optimized path with your preferences');\n    }\n\n    // Step 4: Generate detailed itinerary\n    const detailedItinerary = this.createDetailedItinerary(optimizedPath, transport_mode, budget_range);\n    return detailedItinerary;\n  }\n\n  // Filter locations based on interests\n  filterLocationsByInterests(interests) {\n    if (!interests || interests.length === 0) {\n      return this.locations.slice(0, 8); // Return first 8 locations as default\n    }\n    const filteredLocations = this.locations.filter(location => {\n      const locationTags = location.tags || [];\n      const locationCategory = location.category || '';\n      const locationDescription = location.description || '';\n      return interests.some(interest => {\n        return locationTags.some(tag => tag.toLowerCase().includes(interest.toLowerCase())) || locationCategory.toLowerCase().includes(interest.toLowerCase()) || locationDescription.toLowerCase().includes(interest.toLowerCase());\n      });\n    });\n\n    // If filtered results are too few, add some popular destinations\n    if (filteredLocations.length < 3) {\n      const popularDestinations = this.locations.filter(loc => ['taj-mahal', 'delhi', 'jaipur', 'varanasi', 'hampi'].includes(loc.id));\n      return [...filteredLocations, ...popularDestinations].slice(0, 8);\n    }\n    return filteredLocations.slice(0, 10);\n  }\n\n  // Filter locations by distance from start point\n  filterLocationsByDistance(locations, startLocation, maxDistanceKm) {\n    if (!startLocation || !maxDistanceKm) {\n      return locations;\n    }\n    const filtered = locations.filter(location => {\n      const locationCoords = this.getLocationCoordinates(location);\n      const distance = this.calculateHaversineDistance(startLocation, locationCoords);\n      console.log(`Distance from start to ${location.name}: ${distance}km (max: ${maxDistanceKm}km)`);\n      return distance <= maxDistanceKm;\n    });\n    return filtered;\n  }\n\n  // Optimize path based on distance and travel time using Nearest Neighbor + 2-Opt\n  optimizePath(locations, startLocation, maxDays, maxDistanceKm = null) {\n    if (!locations || locations.length === 0) {\n      return [];\n    }\n\n    // Limit locations based on travel days (roughly 1-2 locations per day)\n    const maxLocations = Math.min(locations.length, Math.ceil(maxDays / 1.5));\n    const limitedLocations = locations.slice(0, maxLocations);\n    if (limitedLocations.length <= 1) {\n      return limitedLocations;\n    }\n\n    // Step 1: Use Nearest Neighbor to get initial route\n    const initialPath = this.nearestNeighborPath(limitedLocations, startLocation, maxDistanceKm, maxLocations);\n    if (initialPath.length <= 2) {\n      return initialPath;\n    }\n\n    // Step 2: Improve the route using 2-Opt algorithm\n    const improvedPath = this.twoOptImprovement(initialPath, startLocation);\n    console.log('Route optimization: Initial distance:', this.calculateTotalDistance(initialPath), 'km, Improved distance:', this.calculateTotalDistance(improvedPath), 'km');\n    return improvedPath;\n  }\n\n  // Nearest Neighbor algorithm for initial path\n  nearestNeighborPath(locations, startLocation, maxDistanceKm, maxLocations) {\n    const optimizedPath = [];\n    const remainingLocations = [...locations];\n\n    // Start with location closest to start point or first location\n    let currentLocation;\n    if (startLocation) {\n      currentLocation = this.findNearestLocation(remainingLocations, startLocation);\n    } else {\n      currentLocation = remainingLocations[0];\n    }\n    optimizedPath.push(currentLocation);\n    const currentIndex = remainingLocations.indexOf(currentLocation);\n    remainingLocations.splice(currentIndex, 1);\n\n    // Add nearest neighbors, ensuring we don't exceed max distance from start\n    while (remainingLocations.length > 0 && optimizedPath.length < maxLocations) {\n      const currentCoords = this.getLocationCoordinates(currentLocation);\n      let nearestLocation = null;\n      let shortestDistance = Infinity;\n      remainingLocations.forEach(loc => {\n        const locCoords = this.getLocationCoordinates(loc);\n        const distance = this.calculateHaversineDistance(currentCoords, locCoords);\n\n        // Additional check: ensure location is within max distance from start if specified\n        if (maxDistanceKm && startLocation) {\n          const distanceFromStart = this.calculateHaversineDistance(startLocation, locCoords);\n          if (distanceFromStart > maxDistanceKm) {\n            return; // Skip this location as it's beyond max distance\n          }\n        }\n        if (distance < shortestDistance) {\n          shortestDistance = distance;\n          nearestLocation = loc;\n        }\n      });\n      if (nearestLocation) {\n        optimizedPath.push(nearestLocation);\n        currentLocation = nearestLocation;\n        const nearestIndex = remainingLocations.indexOf(nearestLocation);\n        remainingLocations.splice(nearestIndex, 1);\n      } else {\n        break;\n      }\n    }\n    return optimizedPath;\n  }\n\n  // 2-Opt improvement algorithm - iteratively improves the route\n  twoOptImprovement(path, startLocation) {\n    if (path.length < 4) {\n      return path; // 2-opt needs at least 4 locations\n    }\n    let improved = true;\n    let currentPath = [...path];\n    let iterations = 0;\n    const maxIterations = 100; // Prevent infinite loops\n\n    while (improved && iterations < maxIterations) {\n      improved = false;\n      iterations++;\n      for (let i = 0; i < currentPath.length - 2; i++) {\n        for (let j = i + 2; j < currentPath.length; j++) {\n          // Skip if we're trying to reverse a segment that includes the start\n          if (startLocation && i === 0 && j === currentPath.length - 1) {\n            continue;\n          }\n          const newPath = this.twoOptSwap(currentPath, i, j);\n          const currentDistance = this.calculateTotalDistance(currentPath);\n          const newDistance = this.calculateTotalDistance(newPath);\n          if (newDistance < currentDistance) {\n            currentPath = newPath;\n            improved = true;\n            break;\n          }\n        }\n        if (improved) break;\n      }\n    }\n    console.log(`2-Opt completed in ${iterations} iterations`);\n    return currentPath;\n  }\n\n  // Perform 2-opt swap - reverse the segment between i and j\n  twoOptSwap(path, i, j) {\n    const newPath = [...path];\n\n    // Reverse the segment between i+1 and j\n    while (i + 1 < j) {\n      i++;\n      [newPath[i], newPath[j]] = [newPath[j], newPath[i]];\n      j--;\n    }\n    return newPath;\n  }\n\n  // Find nearest location to a given point\n  findNearestLocation(locations, point) {\n    let nearest = locations[0];\n    let shortestDistance = Infinity;\n    locations.forEach(location => {\n      const locCoords = this.getLocationCoordinates(location);\n      const distance = this.calculateHaversineDistance(point, locCoords);\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        nearest = location;\n      }\n    });\n    return nearest;\n  }\n\n  // Get coordinates from location object\n  getLocationCoordinates(location) {\n    if (location.coordinates) {\n      if (typeof location.coordinates === 'object' && location.coordinates.lat) {\n        return {\n          lat: location.coordinates.lat,\n          lng: location.coordinates.lng\n        };\n      } else if (Array.isArray(location.coordinates)) {\n        return {\n          lat: location.coordinates[0],\n          lng: location.coordinates[1]\n        };\n      }\n    }\n\n    // Fallback coordinates if not available\n    return {\n      lat: 28.6139,\n      lng: 77.2090\n    }; // Delhi coordinates as fallback\n  }\n\n  // Calculate Haversine distance\n  calculateHaversineDistance(coord1, coord2) {\n    const R = 6371; // Earth's radius in km\n    const lat1 = coord1.lat || coord1[0] || 0;\n    const lng1 = coord1.lng || coord1[1] || 0;\n    const lat2 = coord2.lat || coord2[0] || 0;\n    const lng2 = coord2.lng || coord2[1] || 0;\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return Math.round(R * c);\n  }\n\n  // Create detailed itinerary\n  createDetailedItinerary(path, transportMode, budget) {\n    const itinerary = [];\n    let currentDay = 1;\n    let totalCost = 0;\n    for (let i = 0; i < path.length; i++) {\n      const location = path[i];\n      const nextLocation = path[i + 1];\n\n      // Location exploration days - THIS IS THE MISSING METHOD\n      const daysAtLocation = this.getOptimalDaysAtLocation(location);\n      const dailyCost = this.getAccommodationCost(location.id || location.name, budget) + this.getFoodCost(budget) + this.getLocalTransportCost();\n      for (let day = 0; day < daysAtLocation; day++) {\n        const dayActivity = this.generateDayActivity(location, day, budget);\n        itinerary.push({\n          day: currentDay + day,\n          location: location.name,\n          type: 'exploration',\n          description: dayActivity.description,\n          highlights: dayActivity.highlights,\n          costs: {\n            accommodation: this.getAccommodationCost(location.id || location.name, budget),\n            food: this.getFoodCost(budget),\n            localTransport: this.getLocalTransportCost(),\n            attractions: dayActivity.attractionCosts,\n            total: dailyCost + dayActivity.attractionCosts\n          },\n          culturalInsights: this.getCulturalInsights(location),\n          practicalTips: this.getPracticalTips(location)\n        });\n        totalCost += dailyCost + dayActivity.attractionCosts;\n      }\n      currentDay += daysAtLocation;\n\n      // Travel day\n      if (nextLocation) {\n        const travelDetails = this.getAccurateTravelDetails(location, nextLocation, transportMode);\n        itinerary.push({\n          day: currentDay,\n          location: `${location.name} to ${nextLocation.name}`,\n          type: 'travel',\n          description: `Travel from ${location.name} to ${nextLocation.name} via ${travelDetails.mode}`,\n          travelDetails: travelDetails,\n          costs: {\n            transport: travelDetails.cost,\n            food: travelDetails.mealCost || 0,\n            total: travelDetails.cost + (travelDetails.mealCost || 0)\n          }\n        });\n        totalCost += travelDetails.cost + (travelDetails.mealCost || 0);\n        currentDay++;\n      }\n    }\n    return {\n      id: `ultra-accurate-${Date.now()}`,\n      name: 'Your Culturally Intelligent Route',\n      description: `Scientifically optimized ${path.length}-destination route with cultural depth`,\n      color: '#2196F3',\n      path: path.map(loc => {\n        const coords = this.getLocationCoordinates(loc);\n        return [coords.lat, coords.lng];\n      }),\n      locations: path.map(loc => {\n        const coords = this.getLocationCoordinates(loc);\n        return {\n          name: loc.name,\n          coordinates: [coords.lat, coords.lng],\n          description: loc.description || 'Cultural heritage site'\n        };\n      }),\n      detailedItinerary: itinerary,\n      totalCost: Math.round(totalCost),\n      totalDays: currentDay - 1,\n      culturalThemes: this.extractCulturalThemes(path),\n      optimizationMetrics: {\n        totalDistance: this.calculateTotalDistance(path),\n        culturalDiversity: this.calculateCulturalDiversity(path),\n        costEfficiency: this.calculateCostEfficiency(totalCost, path.length)\n      }\n    };\n  }\n\n  // THE MISSING METHOD - Calculate optimal days at each location\n  getOptimalDaysAtLocation(location) {\n    var _location$name;\n    // Default to 2 days, but adjust based on location importance and attractions\n    const locationName = ((_location$name = location.name) === null || _location$name === void 0 ? void 0 : _location$name.toLowerCase()) || '';\n\n    // Major destinations that need more time\n    const majorDestinations = ['delhi', 'rajasthan', 'taj mahal', 'varanasi', 'hampi'];\n    if (majorDestinations.some(dest => locationName.includes(dest))) {\n      return 3;\n    }\n\n    // UNESCO sites or complex sites\n    const complexSites = ['ajanta', 'ellora', 'khajuraho', 'konark'];\n    if (complexSites.some(site => locationName.includes(site))) {\n      return 2;\n    }\n\n    // Default for most locations\n    return 2;\n  }\n\n  // Helper methods for accurate cost calculation\n  getAccommodationCost(locationId, budget) {\n    const normalizedId = (locationId === null || locationId === void 0 ? void 0 : locationId.toLowerCase().replace(/\\s+/g, '-')) || 'default';\n    const costs = this.accommodationCosts[normalizedId] || {\n      low: 800,\n      medium: 2500,\n      high: 6000\n    };\n    return costs[budget] || costs.medium;\n  }\n  getFoodCost(budget) {\n    const foodCosts = {\n      low: 800,\n      medium: 1500,\n      high: 3000\n    };\n    return foodCosts[budget] || foodCosts.medium;\n  }\n  getLocalTransportCost() {\n    return 500; // Average local transport per day\n  }\n\n  // Generate detailed day activities\n  generateDayActivity(location, dayNumber, budget) {\n    const attractions = this.getLocationAttractions(location.id || location.name);\n    const selectedAttractions = attractions.slice(dayNumber * 2, (dayNumber + 1) * 2);\n    return {\n      description: `Day ${dayNumber + 1} in ${location.name}: ${selectedAttractions.map(a => a.name).join(', ')}`,\n      highlights: selectedAttractions,\n      attractionCosts: selectedAttractions.reduce((sum, attr) => sum + (attr.entryCost || 0), 0)\n    };\n  }\n\n  // Get location-specific attractions with costs\n  getLocationAttractions(locationId) {\n    const attractions = {\n      'delhi': [{\n        name: 'Red Fort',\n        entryCost: 35,\n        time: '3 hours'\n      }, {\n        name: 'India Gate',\n        entryCost: 0,\n        time: '1 hour'\n      }, {\n        name: 'Qutub Minar',\n        entryCost: 30,\n        time: '2 hours'\n      }, {\n        name: 'Lotus Temple',\n        entryCost: 0,\n        time: '1 hour'\n      }],\n      'taj-mahal': [{\n        name: 'Taj Mahal',\n        entryCost: 50,\n        time: '4 hours'\n      }, {\n        name: 'Agra Fort',\n        entryCost: 40,\n        time: '3 hours'\n      }, {\n        name: 'Mehtab Bagh',\n        entryCost: 25,\n        time: '2 hours'\n      }],\n      'jaipur': [{\n        name: 'Amber Fort',\n        entryCost: 25,\n        time: '4 hours'\n      }, {\n        name: 'City Palace',\n        entryCost: 30,\n        time: '3 hours'\n      }, {\n        name: 'Hawa Mahal',\n        entryCost: 15,\n        time: '1 hour'\n      }]\n    };\n    const normalizedId = (locationId === null || locationId === void 0 ? void 0 : locationId.toLowerCase().replace(/\\s+/g, '-')) || 'default';\n    return attractions[normalizedId] || [{\n      name: 'Main Attraction',\n      entryCost: 25,\n      time: '3 hours'\n    }, {\n      name: 'Local Temple',\n      entryCost: 10,\n      time: '2 hours'\n    }, {\n      name: 'Cultural Site',\n      entryCost: 20,\n      time: '2 hours'\n    }];\n  }\n\n  // Get accurate travel details between locations\n  getAccurateTravelDetails(from, to, mode) {\n    const fromCoords = this.getLocationCoordinates(from);\n    const toCoords = this.getLocationCoordinates(to);\n    const distance = this.calculateHaversineDistance(fromCoords, toCoords);\n    const transportMode = mode || 'car';\n    const costPerKm = this.transportationCosts[transportMode] || this.transportationCosts.car;\n    const baseCost = distance * costPerKm;\n\n    // Calculate travel time based on mode\n    const speeds = {\n      car: 60,\n      train: 80,\n      bus: 50,\n      flight: 500\n    }; // km/h\n    const speed = speeds[transportMode] || speeds.car;\n    const travelTimeHours = Math.ceil(distance / speed);\n    return {\n      mode: transportMode,\n      distance: distance,\n      duration: `${travelTimeHours} hours`,\n      cost: Math.round(baseCost),\n      mealCost: travelTimeHours > 4 ? 300 : 0\n    };\n  }\n\n  // Get cultural insights for location\n  getCulturalInsights(location) {\n    return [`Rich cultural heritage dating back centuries`, `Architectural significance in ${location.dynasty || 'regional'} style`, `Important pilgrimage and tourism destination`];\n  }\n\n  // Get practical tips\n  getPracticalTips(location) {\n    return ['Best visited early morning or late afternoon', 'Respect local customs and dress codes', 'Hire local guides for deeper insights', 'Carry water and comfortable walking shoes'];\n  }\n\n  // Extract cultural themes from path\n  extractCulturalThemes(path) {\n    const themes = new Set();\n    path.forEach(location => {\n      if (location.dynasty) themes.add(location.dynasty);\n      if (location.category) themes.add(location.category);\n      if (location.tags) location.tags.forEach(tag => themes.add(tag));\n    });\n    return Array.from(themes);\n  }\n\n  // Calculate total distance\n  calculateTotalDistance(path) {\n    let totalDistance = 0;\n    for (let i = 0; i < path.length - 1; i++) {\n      const current = this.getLocationCoordinates(path[i]);\n      const next = this.getLocationCoordinates(path[i + 1]);\n      totalDistance += this.calculateHaversineDistance(current, next);\n    }\n    return totalDistance;\n  }\n\n  // Calculate cultural diversity score\n  calculateCulturalDiversity(path) {\n    const themes = this.extractCulturalThemes(path);\n    return Math.min(themes.length * 10, 100); // Max 100%\n  }\n\n  // Calculate cost efficiency\n  calculateCostEfficiency(totalCost, numLocations) {\n    const costPerLocation = totalCost / numLocations;\n    return costPerLocation < 5000 ? 'High' : costPerLocation < 8000 ? 'Medium' : 'Low';\n  }\n}","map":{"version":3,"names":["UltraAccurateRoutePlanner","constructor","locations","routes","realDistanceMatrix","transportationCosts","accommodationCosts","low","medium","high","seasonalData","months","bestRegions","temperature","min","max","rainfall","avoidRegions","createUltraAccurateRoute","preferences","console","log","interests","max_travel_days","budget_range","start_location","transport_mode","max_distance_km","candidateLocations","filterLocationsByInterests","length","Error","filterLocationsByDistance","optimizedPath","optimizePath","detailedItinerary","createDetailedItinerary","slice","filteredLocations","filter","location","locationTags","tags","locationCategory","category","locationDescription","description","some","interest","tag","toLowerCase","includes","popularDestinations","loc","id","startLocation","maxDistanceKm","filtered","locationCoords","getLocationCoordinates","distance","calculateHaversineDistance","name","maxDays","maxLocations","Math","ceil","limitedLocations","initialPath","nearestNeighborPath","improvedPath","twoOptImprovement","calculateTotalDistance","remainingLocations","currentLocation","findNearestLocation","push","currentIndex","indexOf","splice","currentCoords","nearestLocation","shortestDistance","Infinity","forEach","locCoords","distanceFromStart","nearestIndex","path","improved","currentPath","iterations","maxIterations","i","j","newPath","twoOptSwap","currentDistance","newDistance","point","nearest","coordinates","lat","lng","Array","isArray","coord1","coord2","R","lat1","lng1","lat2","lng2","dLat","PI","dLng","a","sin","cos","c","atan2","sqrt","round","transportMode","budget","itinerary","currentDay","totalCost","nextLocation","daysAtLocation","getOptimalDaysAtLocation","dailyCost","getAccommodationCost","getFoodCost","getLocalTransportCost","day","dayActivity","generateDayActivity","type","highlights","costs","accommodation","food","localTransport","attractions","attractionCosts","total","culturalInsights","getCulturalInsights","practicalTips","getPracticalTips","travelDetails","getAccurateTravelDetails","mode","transport","cost","mealCost","Date","now","color","map","coords","totalDays","culturalThemes","extractCulturalThemes","optimizationMetrics","totalDistance","culturalDiversity","calculateCulturalDiversity","costEfficiency","calculateCostEfficiency","_location$name","locationName","majorDestinations","dest","complexSites","site","locationId","normalizedId","replace","foodCosts","dayNumber","getLocationAttractions","selectedAttractions","join","reduce","sum","attr","entryCost","time","from","to","fromCoords","toCoords","costPerKm","car","baseCost","speeds","train","bus","flight","speed","travelTimeHours","duration","dynasty","themes","Set","add","current","next","numLocations","costPerLocation"],"sources":["D:/MY projects/CupeKG/cupe-kg-frontend/src/utils/enhancedRoutePlanner.js"],"sourcesContent":["// cupe-kg-frontend/src/utils/enhancedRoutePlanner.js\r\n// FIXED VERSION - Replace your entire enhancedRoutePlanner.js with this\r\n\r\nexport class UltraAccurateRoutePlanner {\r\n  constructor(locations, routes) {\r\n    this.locations = locations || [];\r\n    this.routes = routes || [];\r\n    \r\n    // Real distance matrix (in km) between major Indian cities\r\n    this.realDistanceMatrix = {\r\n      'delhi': {\r\n        'jaipur': 280, 'agra': 233, 'varanasi': 821, 'amritsar': 460,\r\n        'hampi': 1483, 'udaipur': 421, 'khajuraho': 620, 'bodh-gaya': 1105\r\n      },\r\n      'jaipur': {\r\n        'delhi': 280, 'udaipur': 393, 'taj-mahal': 240, 'ajanta': 739\r\n      },\r\n      'taj-mahal': {\r\n        'delhi': 233, 'jaipur': 240, 'khajuraho': 295, 'varanasi': 605\r\n      },\r\n      'varanasi': {\r\n        'delhi': 821, 'bodh-gaya': 250, 'khajuraho': 298, 'kolkata': 679,\r\n        'agra': 605\r\n      },\r\n      'bodh-gaya': {\r\n        'varanasi': 250, 'delhi': 1105, 'kolkata': 495, 'patna': 135\r\n      },\r\n      'hampi': {\r\n        'delhi': 1483, 'madurai': 440\r\n      },\r\n      'madurai': {\r\n        'hampi': 440, 'chennai': 462, 'bangalore': 460, 'kochi': 257\r\n      },\r\n      'amritsar': {\r\n        'delhi': 460, 'chandigarh': 230, 'shimla': 350\r\n      },\r\n      'udaipur': {\r\n        'jaipur': 393, 'delhi': 421, 'mumbai': 734, 'ajanta': 451\r\n      },\r\n      'konark': {\r\n        'bhubaneswar': 65, 'kolkata': 380, 'delhi': 1108\r\n      },\r\n      'ajanta': {\r\n        'ellora': 95, 'mumbai': 440, 'pune': 240, 'udaipur': 451\r\n      },\r\n      'ellora': {\r\n        'ajanta': 95, 'mumbai': 380, 'pune': 220\r\n      }\r\n    };\r\n\r\n    // Transportation costs (INR per km)\r\n    this.transportationCosts = {\r\n      'flight': 3.5,\r\n      'train': 0.75,\r\n      'bus': 0.45,\r\n      'car': 12\r\n    };\r\n\r\n    // Accommodation costs by city (per night)\r\n    this.accommodationCosts = {\r\n      'delhi': { low: 1200, medium: 3500, high: 8500 },\r\n      'jaipur': { low: 800, medium: 2500, high: 6500 },\r\n      'taj-mahal': { low: 900, medium: 2800, high: 7000 },\r\n      'varanasi': { low: 600, medium: 1800, high: 4500 },\r\n      'amritsar': { low: 700, medium: 2000, high: 5000 },\r\n      'udaipur': { low: 1000, medium: 3200, high: 8000 },\r\n      'hampi': { low: 500, medium: 1500, high: 3500 },\r\n      'madurai': { low: 600, medium: 1800, high: 4000 },\r\n      'bodh-gaya': { low: 400, medium: 1200, high: 2800 },\r\n      'konark': { low: 600, medium: 1600, high: 3500 },\r\n      'mahabalipuram': { low: 800, medium: 2200, high: 5500 },\r\n      'ajanta': { low: 600, medium: 1600, high: 3800 },\r\n      'ellora': { low: 600, medium: 1600, high: 3800 },\r\n      'khajuraho': { low: 700, medium: 2000, high: 4500 }\r\n    };\r\n\r\n    // Weather and seasonal data\r\n    this.seasonalData = {\r\n      'winter': {\r\n        months: ['Oct', 'Nov', 'Dec', 'Jan', 'Feb', 'Mar'],\r\n        bestRegions: ['north', 'central', 'west', 'south'],\r\n        temperature: { min: 10, max: 25 },\r\n        rainfall: 'minimal'\r\n      },\r\n      'summer': {\r\n        months: ['Apr', 'May', 'Jun'],\r\n        bestRegions: ['hills', 'north-east'],\r\n        avoidRegions: ['rajasthan', 'central'],\r\n        temperature: { min: 25, max: 45 },\r\n        rainfall: 'none'\r\n      },\r\n      'monsoon': {\r\n        months: ['Jul', 'Aug', 'Sep'],\r\n        bestRegions: ['western-ghats', 'caves'],\r\n        temperature: { min: 20, max: 30 },\r\n        rainfall: 'heavy'\r\n      }\r\n    };\r\n  }\r\n\r\n  // Main route creation function\r\n  createUltraAccurateRoute(preferences) {\r\n    console.log('Creating ultra-accurate route with preferences:', preferences);\r\n\r\n    const {\r\n      interests = [],\r\n      max_travel_days = 7,\r\n      budget_range = 'medium',\r\n      start_location = null,\r\n      transport_mode = 'car',\r\n      max_distance_km = 500\r\n    } = preferences;\r\n\r\n    // Step 1: Filter locations by interests\r\n    let candidateLocations = this.filterLocationsByInterests(interests);\r\n    console.log('Candidate locations found:', candidateLocations.length);\r\n\r\n    if (candidateLocations.length === 0) {\r\n      throw new Error('No locations found matching your interests');\r\n    }\r\n\r\n    // Step 2: Filter locations by distance from start location\r\n    if (start_location && max_distance_km) {\r\n      candidateLocations = this.filterLocationsByDistance(candidateLocations, start_location, max_distance_km);\r\n      console.log(`Locations within ${max_distance_km}km:`, candidateLocations.length);\r\n\r\n      if (candidateLocations.length === 0) {\r\n        throw new Error(`No locations found within ${max_distance_km}km of your starting point. Try increasing the distance limit.`);\r\n      }\r\n    }\r\n\r\n    // Step 3: Create optimized path\r\n    const optimizedPath = this.optimizePath(candidateLocations, start_location, max_travel_days, max_distance_km);\r\n    console.log('Optimized path created:', optimizedPath.length, 'locations');\r\n\r\n    if (optimizedPath.length === 0) {\r\n      throw new Error('Could not create an optimized path with your preferences');\r\n    }\r\n\r\n    // Step 4: Generate detailed itinerary\r\n    const detailedItinerary = this.createDetailedItinerary(optimizedPath, transport_mode, budget_range);\r\n\r\n    return detailedItinerary;\r\n  }\r\n\r\n  // Filter locations based on interests\r\n  filterLocationsByInterests(interests) {\r\n    if (!interests || interests.length === 0) {\r\n      return this.locations.slice(0, 8); // Return first 8 locations as default\r\n    }\r\n\r\n    const filteredLocations = this.locations.filter(location => {\r\n      const locationTags = location.tags || [];\r\n      const locationCategory = location.category || '';\r\n      const locationDescription = location.description || '';\r\n\r\n      return interests.some(interest => {\r\n        return locationTags.some(tag => tag.toLowerCase().includes(interest.toLowerCase())) ||\r\n               locationCategory.toLowerCase().includes(interest.toLowerCase()) ||\r\n               locationDescription.toLowerCase().includes(interest.toLowerCase());\r\n      });\r\n    });\r\n\r\n    // If filtered results are too few, add some popular destinations\r\n    if (filteredLocations.length < 3) {\r\n      const popularDestinations = this.locations.filter(loc =>\r\n        ['taj-mahal', 'delhi', 'jaipur', 'varanasi', 'hampi'].includes(loc.id)\r\n      );\r\n      return [...filteredLocations, ...popularDestinations].slice(0, 8);\r\n    }\r\n\r\n    return filteredLocations.slice(0, 10);\r\n  }\r\n\r\n  // Filter locations by distance from start point\r\n  filterLocationsByDistance(locations, startLocation, maxDistanceKm) {\r\n    if (!startLocation || !maxDistanceKm) {\r\n      return locations;\r\n    }\r\n\r\n    const filtered = locations.filter(location => {\r\n      const locationCoords = this.getLocationCoordinates(location);\r\n      const distance = this.calculateHaversineDistance(startLocation, locationCoords);\r\n\r\n      console.log(`Distance from start to ${location.name}: ${distance}km (max: ${maxDistanceKm}km)`);\r\n\r\n      return distance <= maxDistanceKm;\r\n    });\r\n\r\n    return filtered;\r\n  }\r\n\r\n  // Optimize path based on distance and travel time using Nearest Neighbor + 2-Opt\r\n  optimizePath(locations, startLocation, maxDays, maxDistanceKm = null) {\r\n    if (!locations || locations.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    // Limit locations based on travel days (roughly 1-2 locations per day)\r\n    const maxLocations = Math.min(locations.length, Math.ceil(maxDays / 1.5));\r\n    const limitedLocations = locations.slice(0, maxLocations);\r\n\r\n    if (limitedLocations.length <= 1) {\r\n      return limitedLocations;\r\n    }\r\n\r\n    // Step 1: Use Nearest Neighbor to get initial route\r\n    const initialPath = this.nearestNeighborPath(limitedLocations, startLocation, maxDistanceKm, maxLocations);\r\n\r\n    if (initialPath.length <= 2) {\r\n      return initialPath;\r\n    }\r\n\r\n    // Step 2: Improve the route using 2-Opt algorithm\r\n    const improvedPath = this.twoOptImprovement(initialPath, startLocation);\r\n\r\n    console.log('Route optimization: Initial distance:', this.calculateTotalDistance(initialPath),\r\n                'km, Improved distance:', this.calculateTotalDistance(improvedPath), 'km');\r\n\r\n    return improvedPath;\r\n  }\r\n\r\n  // Nearest Neighbor algorithm for initial path\r\n  nearestNeighborPath(locations, startLocation, maxDistanceKm, maxLocations) {\r\n    const optimizedPath = [];\r\n    const remainingLocations = [...locations];\r\n\r\n    // Start with location closest to start point or first location\r\n    let currentLocation;\r\n    if (startLocation) {\r\n      currentLocation = this.findNearestLocation(remainingLocations, startLocation);\r\n    } else {\r\n      currentLocation = remainingLocations[0];\r\n    }\r\n\r\n    optimizedPath.push(currentLocation);\r\n    const currentIndex = remainingLocations.indexOf(currentLocation);\r\n    remainingLocations.splice(currentIndex, 1);\r\n\r\n    // Add nearest neighbors, ensuring we don't exceed max distance from start\r\n    while (remainingLocations.length > 0 && optimizedPath.length < maxLocations) {\r\n      const currentCoords = this.getLocationCoordinates(currentLocation);\r\n      let nearestLocation = null;\r\n      let shortestDistance = Infinity;\r\n\r\n      remainingLocations.forEach(loc => {\r\n        const locCoords = this.getLocationCoordinates(loc);\r\n        const distance = this.calculateHaversineDistance(currentCoords, locCoords);\r\n\r\n        // Additional check: ensure location is within max distance from start if specified\r\n        if (maxDistanceKm && startLocation) {\r\n          const distanceFromStart = this.calculateHaversineDistance(startLocation, locCoords);\r\n          if (distanceFromStart > maxDistanceKm) {\r\n            return; // Skip this location as it's beyond max distance\r\n          }\r\n        }\r\n\r\n        if (distance < shortestDistance) {\r\n          shortestDistance = distance;\r\n          nearestLocation = loc;\r\n        }\r\n      });\r\n\r\n      if (nearestLocation) {\r\n        optimizedPath.push(nearestLocation);\r\n        currentLocation = nearestLocation;\r\n        const nearestIndex = remainingLocations.indexOf(nearestLocation);\r\n        remainingLocations.splice(nearestIndex, 1);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return optimizedPath;\r\n  }\r\n\r\n  // 2-Opt improvement algorithm - iteratively improves the route\r\n  twoOptImprovement(path, startLocation) {\r\n    if (path.length < 4) {\r\n      return path; // 2-opt needs at least 4 locations\r\n    }\r\n\r\n    let improved = true;\r\n    let currentPath = [...path];\r\n    let iterations = 0;\r\n    const maxIterations = 100; // Prevent infinite loops\r\n\r\n    while (improved && iterations < maxIterations) {\r\n      improved = false;\r\n      iterations++;\r\n\r\n      for (let i = 0; i < currentPath.length - 2; i++) {\r\n        for (let j = i + 2; j < currentPath.length; j++) {\r\n          // Skip if we're trying to reverse a segment that includes the start\r\n          if (startLocation && i === 0 && j === currentPath.length - 1) {\r\n            continue;\r\n          }\r\n\r\n          const newPath = this.twoOptSwap(currentPath, i, j);\r\n          const currentDistance = this.calculateTotalDistance(currentPath);\r\n          const newDistance = this.calculateTotalDistance(newPath);\r\n\r\n          if (newDistance < currentDistance) {\r\n            currentPath = newPath;\r\n            improved = true;\r\n            break;\r\n          }\r\n        }\r\n        if (improved) break;\r\n      }\r\n    }\r\n\r\n    console.log(`2-Opt completed in ${iterations} iterations`);\r\n    return currentPath;\r\n  }\r\n\r\n  // Perform 2-opt swap - reverse the segment between i and j\r\n  twoOptSwap(path, i, j) {\r\n    const newPath = [...path];\r\n\r\n    // Reverse the segment between i+1 and j\r\n    while (i + 1 < j) {\r\n      i++;\r\n      [newPath[i], newPath[j]] = [newPath[j], newPath[i]];\r\n      j--;\r\n    }\r\n\r\n    return newPath;\r\n  }\r\n\r\n  // Find nearest location to a given point\r\n  findNearestLocation(locations, point) {\r\n    let nearest = locations[0];\r\n    let shortestDistance = Infinity;\r\n\r\n    locations.forEach(location => {\r\n      const locCoords = this.getLocationCoordinates(location);\r\n      const distance = this.calculateHaversineDistance(point, locCoords);\r\n      \r\n      if (distance < shortestDistance) {\r\n        shortestDistance = distance;\r\n        nearest = location;\r\n      }\r\n    });\r\n\r\n    return nearest;\r\n  }\r\n\r\n  // Get coordinates from location object\r\n  getLocationCoordinates(location) {\r\n    if (location.coordinates) {\r\n      if (typeof location.coordinates === 'object' && location.coordinates.lat) {\r\n        return { lat: location.coordinates.lat, lng: location.coordinates.lng };\r\n      } else if (Array.isArray(location.coordinates)) {\r\n        return { lat: location.coordinates[0], lng: location.coordinates[1] };\r\n      }\r\n    }\r\n    \r\n    // Fallback coordinates if not available\r\n    return { lat: 28.6139, lng: 77.2090 }; // Delhi coordinates as fallback\r\n  }\r\n\r\n  // Calculate Haversine distance\r\n  calculateHaversineDistance(coord1, coord2) {\r\n    const R = 6371; // Earth's radius in km\r\n    const lat1 = coord1.lat || coord1[0] || 0;\r\n    const lng1 = coord1.lng || coord1[1] || 0;\r\n    const lat2 = coord2.lat || coord2[0] || 0;\r\n    const lng2 = coord2.lng || coord2[1] || 0;\r\n    \r\n    const dLat = (lat2 - lat1) * Math.PI / 180;\r\n    const dLng = (lng2 - lng1) * Math.PI / 180;\r\n    \r\n    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\r\n              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\r\n              Math.sin(dLng/2) * Math.sin(dLng/2);\r\n    \r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\r\n    return Math.round(R * c);\r\n  }\r\n\r\n  // Create detailed itinerary\r\n  createDetailedItinerary(path, transportMode, budget) {\r\n    const itinerary = [];\r\n    let currentDay = 1;\r\n    let totalCost = 0;\r\n    \r\n    for (let i = 0; i < path.length; i++) {\r\n      const location = path[i];\r\n      const nextLocation = path[i + 1];\r\n      \r\n      // Location exploration days - THIS IS THE MISSING METHOD\r\n      const daysAtLocation = this.getOptimalDaysAtLocation(location);\r\n      const dailyCost = this.getAccommodationCost(location.id || location.name, budget) + \r\n                       this.getFoodCost(budget) + \r\n                       this.getLocalTransportCost();\r\n      \r\n      for (let day = 0; day < daysAtLocation; day++) {\r\n        const dayActivity = this.generateDayActivity(location, day, budget);\r\n        itinerary.push({\r\n          day: currentDay + day,\r\n          location: location.name,\r\n          type: 'exploration',\r\n          description: dayActivity.description,\r\n          highlights: dayActivity.highlights,\r\n          costs: {\r\n            accommodation: this.getAccommodationCost(location.id || location.name, budget),\r\n            food: this.getFoodCost(budget),\r\n            localTransport: this.getLocalTransportCost(),\r\n            attractions: dayActivity.attractionCosts,\r\n            total: dailyCost + dayActivity.attractionCosts\r\n          },\r\n          culturalInsights: this.getCulturalInsights(location),\r\n          practicalTips: this.getPracticalTips(location)\r\n        });\r\n        totalCost += dailyCost + dayActivity.attractionCosts;\r\n      }\r\n      \r\n      currentDay += daysAtLocation;\r\n      \r\n      // Travel day\r\n      if (nextLocation) {\r\n        const travelDetails = this.getAccurateTravelDetails(location, nextLocation, transportMode);\r\n        itinerary.push({\r\n          day: currentDay,\r\n          location: `${location.name} to ${nextLocation.name}`,\r\n          type: 'travel',\r\n          description: `Travel from ${location.name} to ${nextLocation.name} via ${travelDetails.mode}`,\r\n          travelDetails: travelDetails,\r\n          costs: {\r\n            transport: travelDetails.cost,\r\n            food: travelDetails.mealCost || 0,\r\n            total: travelDetails.cost + (travelDetails.mealCost || 0)\r\n          }\r\n        });\r\n        totalCost += travelDetails.cost + (travelDetails.mealCost || 0);\r\n        currentDay++;\r\n      }\r\n    }\r\n    \r\n    return {\r\n      id: `ultra-accurate-${Date.now()}`,\r\n      name: 'Your Culturally Intelligent Route',\r\n      description: `Scientifically optimized ${path.length}-destination route with cultural depth`,\r\n      color: '#2196F3',\r\n      path: path.map(loc => {\r\n        const coords = this.getLocationCoordinates(loc);\r\n        return [coords.lat, coords.lng];\r\n      }),\r\n      locations: path.map(loc => {\r\n        const coords = this.getLocationCoordinates(loc);\r\n        return {\r\n          name: loc.name,\r\n          coordinates: [coords.lat, coords.lng],\r\n          description: loc.description || 'Cultural heritage site'\r\n        };\r\n      }),\r\n      detailedItinerary: itinerary,\r\n      totalCost: Math.round(totalCost),\r\n      totalDays: currentDay - 1,\r\n      culturalThemes: this.extractCulturalThemes(path),\r\n      optimizationMetrics: {\r\n        totalDistance: this.calculateTotalDistance(path),\r\n        culturalDiversity: this.calculateCulturalDiversity(path),\r\n        costEfficiency: this.calculateCostEfficiency(totalCost, path.length)\r\n      }\r\n    };\r\n  }\r\n\r\n  // THE MISSING METHOD - Calculate optimal days at each location\r\n  getOptimalDaysAtLocation(location) {\r\n    // Default to 2 days, but adjust based on location importance and attractions\r\n    const locationName = location.name?.toLowerCase() || '';\r\n    \r\n    // Major destinations that need more time\r\n    const majorDestinations = ['delhi', 'rajasthan', 'taj mahal', 'varanasi', 'hampi'];\r\n    if (majorDestinations.some(dest => locationName.includes(dest))) {\r\n      return 3;\r\n    }\r\n    \r\n    // UNESCO sites or complex sites\r\n    const complexSites = ['ajanta', 'ellora', 'khajuraho', 'konark'];\r\n    if (complexSites.some(site => locationName.includes(site))) {\r\n      return 2;\r\n    }\r\n    \r\n    // Default for most locations\r\n    return 2;\r\n  }\r\n\r\n  // Helper methods for accurate cost calculation\r\n  getAccommodationCost(locationId, budget) {\r\n    const normalizedId = locationId?.toLowerCase().replace(/\\s+/g, '-') || 'default';\r\n    const costs = this.accommodationCosts[normalizedId] || { low: 800, medium: 2500, high: 6000 };\r\n    return costs[budget] || costs.medium;\r\n  }\r\n\r\n  getFoodCost(budget) {\r\n    const foodCosts = { low: 800, medium: 1500, high: 3000 };\r\n    return foodCosts[budget] || foodCosts.medium;\r\n  }\r\n\r\n  getLocalTransportCost() {\r\n    return 500; // Average local transport per day\r\n  }\r\n\r\n  // Generate detailed day activities\r\n  generateDayActivity(location, dayNumber, budget) {\r\n    const attractions = this.getLocationAttractions(location.id || location.name);\r\n    const selectedAttractions = attractions.slice(dayNumber * 2, (dayNumber + 1) * 2);\r\n    \r\n    return {\r\n      description: `Day ${dayNumber + 1} in ${location.name}: ${selectedAttractions.map(a => a.name).join(', ')}`,\r\n      highlights: selectedAttractions,\r\n      attractionCosts: selectedAttractions.reduce((sum, attr) => sum + (attr.entryCost || 0), 0)\r\n    };\r\n  }\r\n\r\n  // Get location-specific attractions with costs\r\n  getLocationAttractions(locationId) {\r\n    const attractions = {\r\n      'delhi': [\r\n        { name: 'Red Fort', entryCost: 35, time: '3 hours' },\r\n        { name: 'India Gate', entryCost: 0, time: '1 hour' },\r\n        { name: 'Qutub Minar', entryCost: 30, time: '2 hours' },\r\n        { name: 'Lotus Temple', entryCost: 0, time: '1 hour' }\r\n      ],\r\n      'taj-mahal': [\r\n        { name: 'Taj Mahal', entryCost: 50, time: '4 hours' },\r\n        { name: 'Agra Fort', entryCost: 40, time: '3 hours' },\r\n        { name: 'Mehtab Bagh', entryCost: 25, time: '2 hours' }\r\n      ],\r\n      'jaipur': [\r\n        { name: 'Amber Fort', entryCost: 25, time: '4 hours' },\r\n        { name: 'City Palace', entryCost: 30, time: '3 hours' },\r\n        { name: 'Hawa Mahal', entryCost: 15, time: '1 hour' }\r\n      ]\r\n    };\r\n\r\n    const normalizedId = locationId?.toLowerCase().replace(/\\s+/g, '-') || 'default';\r\n    return attractions[normalizedId] || [\r\n      { name: 'Main Attraction', entryCost: 25, time: '3 hours' },\r\n      { name: 'Local Temple', entryCost: 10, time: '2 hours' },\r\n      { name: 'Cultural Site', entryCost: 20, time: '2 hours' }\r\n    ];\r\n  }\r\n\r\n  // Get accurate travel details between locations\r\n  getAccurateTravelDetails(from, to, mode) {\r\n    const fromCoords = this.getLocationCoordinates(from);\r\n    const toCoords = this.getLocationCoordinates(to);\r\n    const distance = this.calculateHaversineDistance(fromCoords, toCoords);\r\n    \r\n    const transportMode = mode || 'car';\r\n    const costPerKm = this.transportationCosts[transportMode] || this.transportationCosts.car;\r\n    const baseCost = distance * costPerKm;\r\n    \r\n    // Calculate travel time based on mode\r\n    const speeds = { car: 60, train: 80, bus: 50, flight: 500 }; // km/h\r\n    const speed = speeds[transportMode] || speeds.car;\r\n    const travelTimeHours = Math.ceil(distance / speed);\r\n    \r\n    return {\r\n      mode: transportMode,\r\n      distance: distance,\r\n      duration: `${travelTimeHours} hours`,\r\n      cost: Math.round(baseCost),\r\n      mealCost: travelTimeHours > 4 ? 300 : 0\r\n    };\r\n  }\r\n\r\n  // Get cultural insights for location\r\n  getCulturalInsights(location) {\r\n    return [\r\n      `Rich cultural heritage dating back centuries`,\r\n      `Architectural significance in ${location.dynasty || 'regional'} style`,\r\n      `Important pilgrimage and tourism destination`\r\n    ];\r\n  }\r\n\r\n  // Get practical tips\r\n  getPracticalTips(location) {\r\n    return [\r\n      'Best visited early morning or late afternoon',\r\n      'Respect local customs and dress codes',\r\n      'Hire local guides for deeper insights',\r\n      'Carry water and comfortable walking shoes'\r\n    ];\r\n  }\r\n\r\n  // Extract cultural themes from path\r\n  extractCulturalThemes(path) {\r\n    const themes = new Set();\r\n    path.forEach(location => {\r\n      if (location.dynasty) themes.add(location.dynasty);\r\n      if (location.category) themes.add(location.category);\r\n      if (location.tags) location.tags.forEach(tag => themes.add(tag));\r\n    });\r\n    return Array.from(themes);\r\n  }\r\n\r\n  // Calculate total distance\r\n  calculateTotalDistance(path) {\r\n    let totalDistance = 0;\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n      const current = this.getLocationCoordinates(path[i]);\r\n      const next = this.getLocationCoordinates(path[i + 1]);\r\n      totalDistance += this.calculateHaversineDistance(current, next);\r\n    }\r\n    return totalDistance;\r\n  }\r\n\r\n  // Calculate cultural diversity score\r\n  calculateCulturalDiversity(path) {\r\n    const themes = this.extractCulturalThemes(path);\r\n    return Math.min(themes.length * 10, 100); // Max 100%\r\n  }\r\n\r\n  // Calculate cost efficiency\r\n  calculateCostEfficiency(totalCost, numLocations) {\r\n    const costPerLocation = totalCost / numLocations;\r\n    return costPerLocation < 5000 ? 'High' : costPerLocation < 8000 ? 'Medium' : 'Low';\r\n  }\r\n}"],"mappings":"AAAA;AACA;;AAEA,OAAO,MAAMA,yBAAyB,CAAC;EACrCC,WAAWA,CAACC,SAAS,EAAEC,MAAM,EAAE;IAC7B,IAAI,CAACD,SAAS,GAAGA,SAAS,IAAI,EAAE;IAChC,IAAI,CAACC,MAAM,GAAGA,MAAM,IAAI,EAAE;;IAE1B;IACA,IAAI,CAACC,kBAAkB,GAAG;MACxB,OAAO,EAAE;QACP,QAAQ,EAAE,GAAG;QAAE,MAAM,EAAE,GAAG;QAAE,UAAU,EAAE,GAAG;QAAE,UAAU,EAAE,GAAG;QAC5D,OAAO,EAAE,IAAI;QAAE,SAAS,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,WAAW,EAAE;MAChE,CAAC;MACD,QAAQ,EAAE;QACR,OAAO,EAAE,GAAG;QAAE,SAAS,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,QAAQ,EAAE;MAC5D,CAAC;MACD,WAAW,EAAE;QACX,OAAO,EAAE,GAAG;QAAE,QAAQ,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,UAAU,EAAE;MAC7D,CAAC;MACD,UAAU,EAAE;QACV,OAAO,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,SAAS,EAAE,GAAG;QAChE,MAAM,EAAE;MACV,CAAC;MACD,WAAW,EAAE;QACX,UAAU,EAAE,GAAG;QAAE,OAAO,EAAE,IAAI;QAAE,SAAS,EAAE,GAAG;QAAE,OAAO,EAAE;MAC3D,CAAC;MACD,OAAO,EAAE;QACP,OAAO,EAAE,IAAI;QAAE,SAAS,EAAE;MAC5B,CAAC;MACD,SAAS,EAAE;QACT,OAAO,EAAE,GAAG;QAAE,SAAS,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,OAAO,EAAE;MAC3D,CAAC;MACD,UAAU,EAAE;QACV,OAAO,EAAE,GAAG;QAAE,YAAY,EAAE,GAAG;QAAE,QAAQ,EAAE;MAC7C,CAAC;MACD,SAAS,EAAE;QACT,QAAQ,EAAE,GAAG;QAAE,OAAO,EAAE,GAAG;QAAE,QAAQ,EAAE,GAAG;QAAE,QAAQ,EAAE;MACxD,CAAC;MACD,QAAQ,EAAE;QACR,aAAa,EAAE,EAAE;QAAE,SAAS,EAAE,GAAG;QAAE,OAAO,EAAE;MAC9C,CAAC;MACD,QAAQ,EAAE;QACR,QAAQ,EAAE,EAAE;QAAE,QAAQ,EAAE,GAAG;QAAE,MAAM,EAAE,GAAG;QAAE,SAAS,EAAE;MACvD,CAAC;MACD,QAAQ,EAAE;QACR,QAAQ,EAAE,EAAE;QAAE,QAAQ,EAAE,GAAG;QAAE,MAAM,EAAE;MACvC;IACF,CAAC;;IAED;IACA,IAAI,CAACC,mBAAmB,GAAG;MACzB,QAAQ,EAAE,GAAG;MACb,OAAO,EAAE,IAAI;MACb,KAAK,EAAE,IAAI;MACX,KAAK,EAAE;IACT,CAAC;;IAED;IACA,IAAI,CAACC,kBAAkB,GAAG;MACxB,OAAO,EAAE;QAAEC,GAAG,EAAE,IAAI;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAChD,QAAQ,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAChD,WAAW,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MACnD,UAAU,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAClD,UAAU,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAClD,SAAS,EAAE;QAAEF,GAAG,EAAE,IAAI;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAClD,OAAO,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAC/C,SAAS,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MACjD,WAAW,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MACnD,QAAQ,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAChD,eAAe,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MACvD,QAAQ,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAChD,QAAQ,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAChD,WAAW,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK;IACpD,CAAC;;IAED;IACA,IAAI,CAACC,YAAY,GAAG;MAClB,QAAQ,EAAE;QACRC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;QAClDC,WAAW,EAAE,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,CAAC;QAClDC,WAAW,EAAE;UAAEC,GAAG,EAAE,EAAE;UAAEC,GAAG,EAAE;QAAG,CAAC;QACjCC,QAAQ,EAAE;MACZ,CAAC;MACD,QAAQ,EAAE;QACRL,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;QAC7BC,WAAW,EAAE,CAAC,OAAO,EAAE,YAAY,CAAC;QACpCK,YAAY,EAAE,CAAC,WAAW,EAAE,SAAS,CAAC;QACtCJ,WAAW,EAAE;UAAEC,GAAG,EAAE,EAAE;UAAEC,GAAG,EAAE;QAAG,CAAC;QACjCC,QAAQ,EAAE;MACZ,CAAC;MACD,SAAS,EAAE;QACTL,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;QAC7BC,WAAW,EAAE,CAAC,eAAe,EAAE,OAAO,CAAC;QACvCC,WAAW,EAAE;UAAEC,GAAG,EAAE,EAAE;UAAEC,GAAG,EAAE;QAAG,CAAC;QACjCC,QAAQ,EAAE;MACZ;IACF,CAAC;EACH;;EAEA;EACAE,wBAAwBA,CAACC,WAAW,EAAE;IACpCC,OAAO,CAACC,GAAG,CAAC,iDAAiD,EAAEF,WAAW,CAAC;IAE3E,MAAM;MACJG,SAAS,GAAG,EAAE;MACdC,eAAe,GAAG,CAAC;MACnBC,YAAY,GAAG,QAAQ;MACvBC,cAAc,GAAG,IAAI;MACrBC,cAAc,GAAG,KAAK;MACtBC,eAAe,GAAG;IACpB,CAAC,GAAGR,WAAW;;IAEf;IACA,IAAIS,kBAAkB,GAAG,IAAI,CAACC,0BAA0B,CAACP,SAAS,CAAC;IACnEF,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAEO,kBAAkB,CAACE,MAAM,CAAC;IAEpE,IAAIF,kBAAkB,CAACE,MAAM,KAAK,CAAC,EAAE;MACnC,MAAM,IAAIC,KAAK,CAAC,4CAA4C,CAAC;IAC/D;;IAEA;IACA,IAAIN,cAAc,IAAIE,eAAe,EAAE;MACrCC,kBAAkB,GAAG,IAAI,CAACI,yBAAyB,CAACJ,kBAAkB,EAAEH,cAAc,EAAEE,eAAe,CAAC;MACxGP,OAAO,CAACC,GAAG,CAAC,oBAAoBM,eAAe,KAAK,EAAEC,kBAAkB,CAACE,MAAM,CAAC;MAEhF,IAAIF,kBAAkB,CAACE,MAAM,KAAK,CAAC,EAAE;QACnC,MAAM,IAAIC,KAAK,CAAC,6BAA6BJ,eAAe,+DAA+D,CAAC;MAC9H;IACF;;IAEA;IACA,MAAMM,aAAa,GAAG,IAAI,CAACC,YAAY,CAACN,kBAAkB,EAAEH,cAAc,EAAEF,eAAe,EAAEI,eAAe,CAAC;IAC7GP,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEY,aAAa,CAACH,MAAM,EAAE,WAAW,CAAC;IAEzE,IAAIG,aAAa,CAACH,MAAM,KAAK,CAAC,EAAE;MAC9B,MAAM,IAAIC,KAAK,CAAC,0DAA0D,CAAC;IAC7E;;IAEA;IACA,MAAMI,iBAAiB,GAAG,IAAI,CAACC,uBAAuB,CAACH,aAAa,EAAEP,cAAc,EAAEF,YAAY,CAAC;IAEnG,OAAOW,iBAAiB;EAC1B;;EAEA;EACAN,0BAA0BA,CAACP,SAAS,EAAE;IACpC,IAAI,CAACA,SAAS,IAAIA,SAAS,CAACQ,MAAM,KAAK,CAAC,EAAE;MACxC,OAAO,IAAI,CAAC5B,SAAS,CAACmC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACrC;IAEA,MAAMC,iBAAiB,GAAG,IAAI,CAACpC,SAAS,CAACqC,MAAM,CAACC,QAAQ,IAAI;MAC1D,MAAMC,YAAY,GAAGD,QAAQ,CAACE,IAAI,IAAI,EAAE;MACxC,MAAMC,gBAAgB,GAAGH,QAAQ,CAACI,QAAQ,IAAI,EAAE;MAChD,MAAMC,mBAAmB,GAAGL,QAAQ,CAACM,WAAW,IAAI,EAAE;MAEtD,OAAOxB,SAAS,CAACyB,IAAI,CAACC,QAAQ,IAAI;QAChC,OAAOP,YAAY,CAACM,IAAI,CAACE,GAAG,IAAIA,GAAG,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACH,QAAQ,CAACE,WAAW,CAAC,CAAC,CAAC,CAAC,IAC5EP,gBAAgB,CAACO,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACH,QAAQ,CAACE,WAAW,CAAC,CAAC,CAAC,IAC/DL,mBAAmB,CAACK,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACH,QAAQ,CAACE,WAAW,CAAC,CAAC,CAAC;MAC3E,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF;IACA,IAAIZ,iBAAiB,CAACR,MAAM,GAAG,CAAC,EAAE;MAChC,MAAMsB,mBAAmB,GAAG,IAAI,CAAClD,SAAS,CAACqC,MAAM,CAACc,GAAG,IACnD,CAAC,WAAW,EAAE,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,OAAO,CAAC,CAACF,QAAQ,CAACE,GAAG,CAACC,EAAE,CACvE,CAAC;MACD,OAAO,CAAC,GAAGhB,iBAAiB,EAAE,GAAGc,mBAAmB,CAAC,CAACf,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;IACnE;IAEA,OAAOC,iBAAiB,CAACD,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EACvC;;EAEA;EACAL,yBAAyBA,CAAC9B,SAAS,EAAEqD,aAAa,EAAEC,aAAa,EAAE;IACjE,IAAI,CAACD,aAAa,IAAI,CAACC,aAAa,EAAE;MACpC,OAAOtD,SAAS;IAClB;IAEA,MAAMuD,QAAQ,GAAGvD,SAAS,CAACqC,MAAM,CAACC,QAAQ,IAAI;MAC5C,MAAMkB,cAAc,GAAG,IAAI,CAACC,sBAAsB,CAACnB,QAAQ,CAAC;MAC5D,MAAMoB,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAACN,aAAa,EAAEG,cAAc,CAAC;MAE/EtC,OAAO,CAACC,GAAG,CAAC,0BAA0BmB,QAAQ,CAACsB,IAAI,KAAKF,QAAQ,YAAYJ,aAAa,KAAK,CAAC;MAE/F,OAAOI,QAAQ,IAAIJ,aAAa;IAClC,CAAC,CAAC;IAEF,OAAOC,QAAQ;EACjB;;EAEA;EACAvB,YAAYA,CAAChC,SAAS,EAAEqD,aAAa,EAAEQ,OAAO,EAAEP,aAAa,GAAG,IAAI,EAAE;IACpE,IAAI,CAACtD,SAAS,IAAIA,SAAS,CAAC4B,MAAM,KAAK,CAAC,EAAE;MACxC,OAAO,EAAE;IACX;;IAEA;IACA,MAAMkC,YAAY,GAAGC,IAAI,CAACnD,GAAG,CAACZ,SAAS,CAAC4B,MAAM,EAAEmC,IAAI,CAACC,IAAI,CAACH,OAAO,GAAG,GAAG,CAAC,CAAC;IACzE,MAAMI,gBAAgB,GAAGjE,SAAS,CAACmC,KAAK,CAAC,CAAC,EAAE2B,YAAY,CAAC;IAEzD,IAAIG,gBAAgB,CAACrC,MAAM,IAAI,CAAC,EAAE;MAChC,OAAOqC,gBAAgB;IACzB;;IAEA;IACA,MAAMC,WAAW,GAAG,IAAI,CAACC,mBAAmB,CAACF,gBAAgB,EAAEZ,aAAa,EAAEC,aAAa,EAAEQ,YAAY,CAAC;IAE1G,IAAII,WAAW,CAACtC,MAAM,IAAI,CAAC,EAAE;MAC3B,OAAOsC,WAAW;IACpB;;IAEA;IACA,MAAME,YAAY,GAAG,IAAI,CAACC,iBAAiB,CAACH,WAAW,EAAEb,aAAa,CAAC;IAEvEnC,OAAO,CAACC,GAAG,CAAC,uCAAuC,EAAE,IAAI,CAACmD,sBAAsB,CAACJ,WAAW,CAAC,EACjF,wBAAwB,EAAE,IAAI,CAACI,sBAAsB,CAACF,YAAY,CAAC,EAAE,IAAI,CAAC;IAEtF,OAAOA,YAAY;EACrB;;EAEA;EACAD,mBAAmBA,CAACnE,SAAS,EAAEqD,aAAa,EAAEC,aAAa,EAAEQ,YAAY,EAAE;IACzE,MAAM/B,aAAa,GAAG,EAAE;IACxB,MAAMwC,kBAAkB,GAAG,CAAC,GAAGvE,SAAS,CAAC;;IAEzC;IACA,IAAIwE,eAAe;IACnB,IAAInB,aAAa,EAAE;MACjBmB,eAAe,GAAG,IAAI,CAACC,mBAAmB,CAACF,kBAAkB,EAAElB,aAAa,CAAC;IAC/E,CAAC,MAAM;MACLmB,eAAe,GAAGD,kBAAkB,CAAC,CAAC,CAAC;IACzC;IAEAxC,aAAa,CAAC2C,IAAI,CAACF,eAAe,CAAC;IACnC,MAAMG,YAAY,GAAGJ,kBAAkB,CAACK,OAAO,CAACJ,eAAe,CAAC;IAChED,kBAAkB,CAACM,MAAM,CAACF,YAAY,EAAE,CAAC,CAAC;;IAE1C;IACA,OAAOJ,kBAAkB,CAAC3C,MAAM,GAAG,CAAC,IAAIG,aAAa,CAACH,MAAM,GAAGkC,YAAY,EAAE;MAC3E,MAAMgB,aAAa,GAAG,IAAI,CAACrB,sBAAsB,CAACe,eAAe,CAAC;MAClE,IAAIO,eAAe,GAAG,IAAI;MAC1B,IAAIC,gBAAgB,GAAGC,QAAQ;MAE/BV,kBAAkB,CAACW,OAAO,CAAC/B,GAAG,IAAI;QAChC,MAAMgC,SAAS,GAAG,IAAI,CAAC1B,sBAAsB,CAACN,GAAG,CAAC;QAClD,MAAMO,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAACmB,aAAa,EAAEK,SAAS,CAAC;;QAE1E;QACA,IAAI7B,aAAa,IAAID,aAAa,EAAE;UAClC,MAAM+B,iBAAiB,GAAG,IAAI,CAACzB,0BAA0B,CAACN,aAAa,EAAE8B,SAAS,CAAC;UACnF,IAAIC,iBAAiB,GAAG9B,aAAa,EAAE;YACrC,OAAO,CAAC;UACV;QACF;QAEA,IAAII,QAAQ,GAAGsB,gBAAgB,EAAE;UAC/BA,gBAAgB,GAAGtB,QAAQ;UAC3BqB,eAAe,GAAG5B,GAAG;QACvB;MACF,CAAC,CAAC;MAEF,IAAI4B,eAAe,EAAE;QACnBhD,aAAa,CAAC2C,IAAI,CAACK,eAAe,CAAC;QACnCP,eAAe,GAAGO,eAAe;QACjC,MAAMM,YAAY,GAAGd,kBAAkB,CAACK,OAAO,CAACG,eAAe,CAAC;QAChER,kBAAkB,CAACM,MAAM,CAACQ,YAAY,EAAE,CAAC,CAAC;MAC5C,CAAC,MAAM;QACL;MACF;IACF;IAEA,OAAOtD,aAAa;EACtB;;EAEA;EACAsC,iBAAiBA,CAACiB,IAAI,EAAEjC,aAAa,EAAE;IACrC,IAAIiC,IAAI,CAAC1D,MAAM,GAAG,CAAC,EAAE;MACnB,OAAO0D,IAAI,CAAC,CAAC;IACf;IAEA,IAAIC,QAAQ,GAAG,IAAI;IACnB,IAAIC,WAAW,GAAG,CAAC,GAAGF,IAAI,CAAC;IAC3B,IAAIG,UAAU,GAAG,CAAC;IAClB,MAAMC,aAAa,GAAG,GAAG,CAAC,CAAC;;IAE3B,OAAOH,QAAQ,IAAIE,UAAU,GAAGC,aAAa,EAAE;MAC7CH,QAAQ,GAAG,KAAK;MAChBE,UAAU,EAAE;MAEZ,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,WAAW,CAAC5D,MAAM,GAAG,CAAC,EAAE+D,CAAC,EAAE,EAAE;QAC/C,KAAK,IAAIC,CAAC,GAAGD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGJ,WAAW,CAAC5D,MAAM,EAAEgE,CAAC,EAAE,EAAE;UAC/C;UACA,IAAIvC,aAAa,IAAIsC,CAAC,KAAK,CAAC,IAAIC,CAAC,KAAKJ,WAAW,CAAC5D,MAAM,GAAG,CAAC,EAAE;YAC5D;UACF;UAEA,MAAMiE,OAAO,GAAG,IAAI,CAACC,UAAU,CAACN,WAAW,EAAEG,CAAC,EAAEC,CAAC,CAAC;UAClD,MAAMG,eAAe,GAAG,IAAI,CAACzB,sBAAsB,CAACkB,WAAW,CAAC;UAChE,MAAMQ,WAAW,GAAG,IAAI,CAAC1B,sBAAsB,CAACuB,OAAO,CAAC;UAExD,IAAIG,WAAW,GAAGD,eAAe,EAAE;YACjCP,WAAW,GAAGK,OAAO;YACrBN,QAAQ,GAAG,IAAI;YACf;UACF;QACF;QACA,IAAIA,QAAQ,EAAE;MAChB;IACF;IAEArE,OAAO,CAACC,GAAG,CAAC,sBAAsBsE,UAAU,aAAa,CAAC;IAC1D,OAAOD,WAAW;EACpB;;EAEA;EACAM,UAAUA,CAACR,IAAI,EAAEK,CAAC,EAAEC,CAAC,EAAE;IACrB,MAAMC,OAAO,GAAG,CAAC,GAAGP,IAAI,CAAC;;IAEzB;IACA,OAAOK,CAAC,GAAG,CAAC,GAAGC,CAAC,EAAE;MAChBD,CAAC,EAAE;MACH,CAACE,OAAO,CAACF,CAAC,CAAC,EAAEE,OAAO,CAACD,CAAC,CAAC,CAAC,GAAG,CAACC,OAAO,CAACD,CAAC,CAAC,EAAEC,OAAO,CAACF,CAAC,CAAC,CAAC;MACnDC,CAAC,EAAE;IACL;IAEA,OAAOC,OAAO;EAChB;;EAEA;EACApB,mBAAmBA,CAACzE,SAAS,EAAEiG,KAAK,EAAE;IACpC,IAAIC,OAAO,GAAGlG,SAAS,CAAC,CAAC,CAAC;IAC1B,IAAIgF,gBAAgB,GAAGC,QAAQ;IAE/BjF,SAAS,CAACkF,OAAO,CAAC5C,QAAQ,IAAI;MAC5B,MAAM6C,SAAS,GAAG,IAAI,CAAC1B,sBAAsB,CAACnB,QAAQ,CAAC;MACvD,MAAMoB,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAACsC,KAAK,EAAEd,SAAS,CAAC;MAElE,IAAIzB,QAAQ,GAAGsB,gBAAgB,EAAE;QAC/BA,gBAAgB,GAAGtB,QAAQ;QAC3BwC,OAAO,GAAG5D,QAAQ;MACpB;IACF,CAAC,CAAC;IAEF,OAAO4D,OAAO;EAChB;;EAEA;EACAzC,sBAAsBA,CAACnB,QAAQ,EAAE;IAC/B,IAAIA,QAAQ,CAAC6D,WAAW,EAAE;MACxB,IAAI,OAAO7D,QAAQ,CAAC6D,WAAW,KAAK,QAAQ,IAAI7D,QAAQ,CAAC6D,WAAW,CAACC,GAAG,EAAE;QACxE,OAAO;UAAEA,GAAG,EAAE9D,QAAQ,CAAC6D,WAAW,CAACC,GAAG;UAAEC,GAAG,EAAE/D,QAAQ,CAAC6D,WAAW,CAACE;QAAI,CAAC;MACzE,CAAC,MAAM,IAAIC,KAAK,CAACC,OAAO,CAACjE,QAAQ,CAAC6D,WAAW,CAAC,EAAE;QAC9C,OAAO;UAAEC,GAAG,EAAE9D,QAAQ,CAAC6D,WAAW,CAAC,CAAC,CAAC;UAAEE,GAAG,EAAE/D,QAAQ,CAAC6D,WAAW,CAAC,CAAC;QAAE,CAAC;MACvE;IACF;;IAEA;IACA,OAAO;MAAEC,GAAG,EAAE,OAAO;MAAEC,GAAG,EAAE;IAAQ,CAAC,CAAC,CAAC;EACzC;;EAEA;EACA1C,0BAA0BA,CAAC6C,MAAM,EAAEC,MAAM,EAAE;IACzC,MAAMC,CAAC,GAAG,IAAI,CAAC,CAAC;IAChB,MAAMC,IAAI,GAAGH,MAAM,CAACJ,GAAG,IAAII,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IACzC,MAAMI,IAAI,GAAGJ,MAAM,CAACH,GAAG,IAAIG,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IACzC,MAAMK,IAAI,GAAGJ,MAAM,CAACL,GAAG,IAAIK,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IACzC,MAAMK,IAAI,GAAGL,MAAM,CAACJ,GAAG,IAAII,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IAEzC,MAAMM,IAAI,GAAG,CAACF,IAAI,GAAGF,IAAI,IAAI5C,IAAI,CAACiD,EAAE,GAAG,GAAG;IAC1C,MAAMC,IAAI,GAAG,CAACH,IAAI,GAAGF,IAAI,IAAI7C,IAAI,CAACiD,EAAE,GAAG,GAAG;IAE1C,MAAME,CAAC,GAAGnD,IAAI,CAACoD,GAAG,CAACJ,IAAI,GAAC,CAAC,CAAC,GAAGhD,IAAI,CAACoD,GAAG,CAACJ,IAAI,GAAC,CAAC,CAAC,GACnChD,IAAI,CAACqD,GAAG,CAACT,IAAI,GAAG5C,IAAI,CAACiD,EAAE,GAAG,GAAG,CAAC,GAAGjD,IAAI,CAACqD,GAAG,CAACP,IAAI,GAAG9C,IAAI,CAACiD,EAAE,GAAG,GAAG,CAAC,GAC/DjD,IAAI,CAACoD,GAAG,CAACF,IAAI,GAAC,CAAC,CAAC,GAAGlD,IAAI,CAACoD,GAAG,CAACF,IAAI,GAAC,CAAC,CAAC;IAE7C,MAAMI,CAAC,GAAG,CAAC,GAAGtD,IAAI,CAACuD,KAAK,CAACvD,IAAI,CAACwD,IAAI,CAACL,CAAC,CAAC,EAAEnD,IAAI,CAACwD,IAAI,CAAC,CAAC,GAACL,CAAC,CAAC,CAAC;IACtD,OAAOnD,IAAI,CAACyD,KAAK,CAACd,CAAC,GAAGW,CAAC,CAAC;EAC1B;;EAEA;EACAnF,uBAAuBA,CAACoD,IAAI,EAAEmC,aAAa,EAAEC,MAAM,EAAE;IACnD,MAAMC,SAAS,GAAG,EAAE;IACpB,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAIC,SAAS,GAAG,CAAC;IAEjB,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,IAAI,CAAC1D,MAAM,EAAE+D,CAAC,EAAE,EAAE;MACpC,MAAMrD,QAAQ,GAAGgD,IAAI,CAACK,CAAC,CAAC;MACxB,MAAMmC,YAAY,GAAGxC,IAAI,CAACK,CAAC,GAAG,CAAC,CAAC;;MAEhC;MACA,MAAMoC,cAAc,GAAG,IAAI,CAACC,wBAAwB,CAAC1F,QAAQ,CAAC;MAC9D,MAAM2F,SAAS,GAAG,IAAI,CAACC,oBAAoB,CAAC5F,QAAQ,CAACc,EAAE,IAAId,QAAQ,CAACsB,IAAI,EAAE8D,MAAM,CAAC,GAChE,IAAI,CAACS,WAAW,CAACT,MAAM,CAAC,GACxB,IAAI,CAACU,qBAAqB,CAAC,CAAC;MAE7C,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGN,cAAc,EAAEM,GAAG,EAAE,EAAE;QAC7C,MAAMC,WAAW,GAAG,IAAI,CAACC,mBAAmB,CAACjG,QAAQ,EAAE+F,GAAG,EAAEX,MAAM,CAAC;QACnEC,SAAS,CAACjD,IAAI,CAAC;UACb2D,GAAG,EAAET,UAAU,GAAGS,GAAG;UACrB/F,QAAQ,EAAEA,QAAQ,CAACsB,IAAI;UACvB4E,IAAI,EAAE,aAAa;UACnB5F,WAAW,EAAE0F,WAAW,CAAC1F,WAAW;UACpC6F,UAAU,EAAEH,WAAW,CAACG,UAAU;UAClCC,KAAK,EAAE;YACLC,aAAa,EAAE,IAAI,CAACT,oBAAoB,CAAC5F,QAAQ,CAACc,EAAE,IAAId,QAAQ,CAACsB,IAAI,EAAE8D,MAAM,CAAC;YAC9EkB,IAAI,EAAE,IAAI,CAACT,WAAW,CAACT,MAAM,CAAC;YAC9BmB,cAAc,EAAE,IAAI,CAACT,qBAAqB,CAAC,CAAC;YAC5CU,WAAW,EAAER,WAAW,CAACS,eAAe;YACxCC,KAAK,EAAEf,SAAS,GAAGK,WAAW,CAACS;UACjC,CAAC;UACDE,gBAAgB,EAAE,IAAI,CAACC,mBAAmB,CAAC5G,QAAQ,CAAC;UACpD6G,aAAa,EAAE,IAAI,CAACC,gBAAgB,CAAC9G,QAAQ;QAC/C,CAAC,CAAC;QACFuF,SAAS,IAAII,SAAS,GAAGK,WAAW,CAACS,eAAe;MACtD;MAEAnB,UAAU,IAAIG,cAAc;;MAE5B;MACA,IAAID,YAAY,EAAE;QAChB,MAAMuB,aAAa,GAAG,IAAI,CAACC,wBAAwB,CAAChH,QAAQ,EAAEwF,YAAY,EAAEL,aAAa,CAAC;QAC1FE,SAAS,CAACjD,IAAI,CAAC;UACb2D,GAAG,EAAET,UAAU;UACftF,QAAQ,EAAE,GAAGA,QAAQ,CAACsB,IAAI,OAAOkE,YAAY,CAAClE,IAAI,EAAE;UACpD4E,IAAI,EAAE,QAAQ;UACd5F,WAAW,EAAE,eAAeN,QAAQ,CAACsB,IAAI,OAAOkE,YAAY,CAAClE,IAAI,QAAQyF,aAAa,CAACE,IAAI,EAAE;UAC7FF,aAAa,EAAEA,aAAa;UAC5BX,KAAK,EAAE;YACLc,SAAS,EAAEH,aAAa,CAACI,IAAI;YAC7Bb,IAAI,EAAES,aAAa,CAACK,QAAQ,IAAI,CAAC;YACjCV,KAAK,EAAEK,aAAa,CAACI,IAAI,IAAIJ,aAAa,CAACK,QAAQ,IAAI,CAAC;UAC1D;QACF,CAAC,CAAC;QACF7B,SAAS,IAAIwB,aAAa,CAACI,IAAI,IAAIJ,aAAa,CAACK,QAAQ,IAAI,CAAC,CAAC;QAC/D9B,UAAU,EAAE;MACd;IACF;IAEA,OAAO;MACLxE,EAAE,EAAE,kBAAkBuG,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MAClChG,IAAI,EAAE,mCAAmC;MACzChB,WAAW,EAAE,4BAA4B0C,IAAI,CAAC1D,MAAM,wCAAwC;MAC5FiI,KAAK,EAAE,SAAS;MAChBvE,IAAI,EAAEA,IAAI,CAACwE,GAAG,CAAC3G,GAAG,IAAI;QACpB,MAAM4G,MAAM,GAAG,IAAI,CAACtG,sBAAsB,CAACN,GAAG,CAAC;QAC/C,OAAO,CAAC4G,MAAM,CAAC3D,GAAG,EAAE2D,MAAM,CAAC1D,GAAG,CAAC;MACjC,CAAC,CAAC;MACFrG,SAAS,EAAEsF,IAAI,CAACwE,GAAG,CAAC3G,GAAG,IAAI;QACzB,MAAM4G,MAAM,GAAG,IAAI,CAACtG,sBAAsB,CAACN,GAAG,CAAC;QAC/C,OAAO;UACLS,IAAI,EAAET,GAAG,CAACS,IAAI;UACduC,WAAW,EAAE,CAAC4D,MAAM,CAAC3D,GAAG,EAAE2D,MAAM,CAAC1D,GAAG,CAAC;UACrCzD,WAAW,EAAEO,GAAG,CAACP,WAAW,IAAI;QAClC,CAAC;MACH,CAAC,CAAC;MACFX,iBAAiB,EAAE0F,SAAS;MAC5BE,SAAS,EAAE9D,IAAI,CAACyD,KAAK,CAACK,SAAS,CAAC;MAChCmC,SAAS,EAAEpC,UAAU,GAAG,CAAC;MACzBqC,cAAc,EAAE,IAAI,CAACC,qBAAqB,CAAC5E,IAAI,CAAC;MAChD6E,mBAAmB,EAAE;QACnBC,aAAa,EAAE,IAAI,CAAC9F,sBAAsB,CAACgB,IAAI,CAAC;QAChD+E,iBAAiB,EAAE,IAAI,CAACC,0BAA0B,CAAChF,IAAI,CAAC;QACxDiF,cAAc,EAAE,IAAI,CAACC,uBAAuB,CAAC3C,SAAS,EAAEvC,IAAI,CAAC1D,MAAM;MACrE;IACF,CAAC;EACH;;EAEA;EACAoG,wBAAwBA,CAAC1F,QAAQ,EAAE;IAAA,IAAAmI,cAAA;IACjC;IACA,MAAMC,YAAY,GAAG,EAAAD,cAAA,GAAAnI,QAAQ,CAACsB,IAAI,cAAA6G,cAAA,uBAAbA,cAAA,CAAezH,WAAW,CAAC,CAAC,KAAI,EAAE;;IAEvD;IACA,MAAM2H,iBAAiB,GAAG,CAAC,OAAO,EAAE,WAAW,EAAE,WAAW,EAAE,UAAU,EAAE,OAAO,CAAC;IAClF,IAAIA,iBAAiB,CAAC9H,IAAI,CAAC+H,IAAI,IAAIF,YAAY,CAACzH,QAAQ,CAAC2H,IAAI,CAAC,CAAC,EAAE;MAC/D,OAAO,CAAC;IACV;;IAEA;IACA,MAAMC,YAAY,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,WAAW,EAAE,QAAQ,CAAC;IAChE,IAAIA,YAAY,CAAChI,IAAI,CAACiI,IAAI,IAAIJ,YAAY,CAACzH,QAAQ,CAAC6H,IAAI,CAAC,CAAC,EAAE;MAC1D,OAAO,CAAC;IACV;;IAEA;IACA,OAAO,CAAC;EACV;;EAEA;EACA5C,oBAAoBA,CAAC6C,UAAU,EAAErD,MAAM,EAAE;IACvC,MAAMsD,YAAY,GAAG,CAAAD,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE/H,WAAW,CAAC,CAAC,CAACiI,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,KAAI,SAAS;IAChF,MAAMvC,KAAK,GAAG,IAAI,CAACtI,kBAAkB,CAAC4K,YAAY,CAAC,IAAI;MAAE3K,GAAG,EAAE,GAAG;MAAEC,MAAM,EAAE,IAAI;MAAEC,IAAI,EAAE;IAAK,CAAC;IAC7F,OAAOmI,KAAK,CAAChB,MAAM,CAAC,IAAIgB,KAAK,CAACpI,MAAM;EACtC;EAEA6H,WAAWA,CAACT,MAAM,EAAE;IAClB,MAAMwD,SAAS,GAAG;MAAE7K,GAAG,EAAE,GAAG;MAAEC,MAAM,EAAE,IAAI;MAAEC,IAAI,EAAE;IAAK,CAAC;IACxD,OAAO2K,SAAS,CAACxD,MAAM,CAAC,IAAIwD,SAAS,CAAC5K,MAAM;EAC9C;EAEA8H,qBAAqBA,CAAA,EAAG;IACtB,OAAO,GAAG,CAAC,CAAC;EACd;;EAEA;EACAG,mBAAmBA,CAACjG,QAAQ,EAAE6I,SAAS,EAAEzD,MAAM,EAAE;IAC/C,MAAMoB,WAAW,GAAG,IAAI,CAACsC,sBAAsB,CAAC9I,QAAQ,CAACc,EAAE,IAAId,QAAQ,CAACsB,IAAI,CAAC;IAC7E,MAAMyH,mBAAmB,GAAGvC,WAAW,CAAC3G,KAAK,CAACgJ,SAAS,GAAG,CAAC,EAAE,CAACA,SAAS,GAAG,CAAC,IAAI,CAAC,CAAC;IAEjF,OAAO;MACLvI,WAAW,EAAE,OAAOuI,SAAS,GAAG,CAAC,OAAO7I,QAAQ,CAACsB,IAAI,KAAKyH,mBAAmB,CAACvB,GAAG,CAAC5C,CAAC,IAAIA,CAAC,CAACtD,IAAI,CAAC,CAAC0H,IAAI,CAAC,IAAI,CAAC,EAAE;MAC3G7C,UAAU,EAAE4C,mBAAmB;MAC/BtC,eAAe,EAAEsC,mBAAmB,CAACE,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAKD,GAAG,IAAIC,IAAI,CAACC,SAAS,IAAI,CAAC,CAAC,EAAE,CAAC;IAC3F,CAAC;EACH;;EAEA;EACAN,sBAAsBA,CAACL,UAAU,EAAE;IACjC,MAAMjC,WAAW,GAAG;MAClB,OAAO,EAAE,CACP;QAAElF,IAAI,EAAE,UAAU;QAAE8H,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACpD;QAAE/H,IAAI,EAAE,YAAY;QAAE8H,SAAS,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAS,CAAC,EACpD;QAAE/H,IAAI,EAAE,aAAa;QAAE8H,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACvD;QAAE/H,IAAI,EAAE,cAAc;QAAE8H,SAAS,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAS,CAAC,CACvD;MACD,WAAW,EAAE,CACX;QAAE/H,IAAI,EAAE,WAAW;QAAE8H,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACrD;QAAE/H,IAAI,EAAE,WAAW;QAAE8H,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACrD;QAAE/H,IAAI,EAAE,aAAa;QAAE8H,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,CACxD;MACD,QAAQ,EAAE,CACR;QAAE/H,IAAI,EAAE,YAAY;QAAE8H,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACtD;QAAE/H,IAAI,EAAE,aAAa;QAAE8H,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACvD;QAAE/H,IAAI,EAAE,YAAY;QAAE8H,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAS,CAAC;IAEzD,CAAC;IAED,MAAMX,YAAY,GAAG,CAAAD,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE/H,WAAW,CAAC,CAAC,CAACiI,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,KAAI,SAAS;IAChF,OAAOnC,WAAW,CAACkC,YAAY,CAAC,IAAI,CAClC;MAAEpH,IAAI,EAAE,iBAAiB;MAAE8H,SAAS,EAAE,EAAE;MAAEC,IAAI,EAAE;IAAU,CAAC,EAC3D;MAAE/H,IAAI,EAAE,cAAc;MAAE8H,SAAS,EAAE,EAAE;MAAEC,IAAI,EAAE;IAAU,CAAC,EACxD;MAAE/H,IAAI,EAAE,eAAe;MAAE8H,SAAS,EAAE,EAAE;MAAEC,IAAI,EAAE;IAAU,CAAC,CAC1D;EACH;;EAEA;EACArC,wBAAwBA,CAACsC,IAAI,EAAEC,EAAE,EAAEtC,IAAI,EAAE;IACvC,MAAMuC,UAAU,GAAG,IAAI,CAACrI,sBAAsB,CAACmI,IAAI,CAAC;IACpD,MAAMG,QAAQ,GAAG,IAAI,CAACtI,sBAAsB,CAACoI,EAAE,CAAC;IAChD,MAAMnI,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAACmI,UAAU,EAAEC,QAAQ,CAAC;IAEtE,MAAMtE,aAAa,GAAG8B,IAAI,IAAI,KAAK;IACnC,MAAMyC,SAAS,GAAG,IAAI,CAAC7L,mBAAmB,CAACsH,aAAa,CAAC,IAAI,IAAI,CAACtH,mBAAmB,CAAC8L,GAAG;IACzF,MAAMC,QAAQ,GAAGxI,QAAQ,GAAGsI,SAAS;;IAErC;IACA,MAAMG,MAAM,GAAG;MAAEF,GAAG,EAAE,EAAE;MAAEG,KAAK,EAAE,EAAE;MAAEC,GAAG,EAAE,EAAE;MAAEC,MAAM,EAAE;IAAI,CAAC,CAAC,CAAC;IAC7D,MAAMC,KAAK,GAAGJ,MAAM,CAAC1E,aAAa,CAAC,IAAI0E,MAAM,CAACF,GAAG;IACjD,MAAMO,eAAe,GAAGzI,IAAI,CAACC,IAAI,CAACN,QAAQ,GAAG6I,KAAK,CAAC;IAEnD,OAAO;MACLhD,IAAI,EAAE9B,aAAa;MACnB/D,QAAQ,EAAEA,QAAQ;MAClB+I,QAAQ,EAAE,GAAGD,eAAe,QAAQ;MACpC/C,IAAI,EAAE1F,IAAI,CAACyD,KAAK,CAAC0E,QAAQ,CAAC;MAC1BxC,QAAQ,EAAE8C,eAAe,GAAG,CAAC,GAAG,GAAG,GAAG;IACxC,CAAC;EACH;;EAEA;EACAtD,mBAAmBA,CAAC5G,QAAQ,EAAE;IAC5B,OAAO,CACL,8CAA8C,EAC9C,iCAAiCA,QAAQ,CAACoK,OAAO,IAAI,UAAU,QAAQ,EACvE,8CAA8C,CAC/C;EACH;;EAEA;EACAtD,gBAAgBA,CAAC9G,QAAQ,EAAE;IACzB,OAAO,CACL,8CAA8C,EAC9C,uCAAuC,EACvC,uCAAuC,EACvC,2CAA2C,CAC5C;EACH;;EAEA;EACA4H,qBAAqBA,CAAC5E,IAAI,EAAE;IAC1B,MAAMqH,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;IACxBtH,IAAI,CAACJ,OAAO,CAAC5C,QAAQ,IAAI;MACvB,IAAIA,QAAQ,CAACoK,OAAO,EAAEC,MAAM,CAACE,GAAG,CAACvK,QAAQ,CAACoK,OAAO,CAAC;MAClD,IAAIpK,QAAQ,CAACI,QAAQ,EAAEiK,MAAM,CAACE,GAAG,CAACvK,QAAQ,CAACI,QAAQ,CAAC;MACpD,IAAIJ,QAAQ,CAACE,IAAI,EAAEF,QAAQ,CAACE,IAAI,CAAC0C,OAAO,CAACnC,GAAG,IAAI4J,MAAM,CAACE,GAAG,CAAC9J,GAAG,CAAC,CAAC;IAClE,CAAC,CAAC;IACF,OAAOuD,KAAK,CAACsF,IAAI,CAACe,MAAM,CAAC;EAC3B;;EAEA;EACArI,sBAAsBA,CAACgB,IAAI,EAAE;IAC3B,IAAI8E,aAAa,GAAG,CAAC;IACrB,KAAK,IAAIzE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,IAAI,CAAC1D,MAAM,GAAG,CAAC,EAAE+D,CAAC,EAAE,EAAE;MACxC,MAAMmH,OAAO,GAAG,IAAI,CAACrJ,sBAAsB,CAAC6B,IAAI,CAACK,CAAC,CAAC,CAAC;MACpD,MAAMoH,IAAI,GAAG,IAAI,CAACtJ,sBAAsB,CAAC6B,IAAI,CAACK,CAAC,GAAG,CAAC,CAAC,CAAC;MACrDyE,aAAa,IAAI,IAAI,CAACzG,0BAA0B,CAACmJ,OAAO,EAAEC,IAAI,CAAC;IACjE;IACA,OAAO3C,aAAa;EACtB;;EAEA;EACAE,0BAA0BA,CAAChF,IAAI,EAAE;IAC/B,MAAMqH,MAAM,GAAG,IAAI,CAACzC,qBAAqB,CAAC5E,IAAI,CAAC;IAC/C,OAAOvB,IAAI,CAACnD,GAAG,CAAC+L,MAAM,CAAC/K,MAAM,GAAG,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC;EAC5C;;EAEA;EACA4I,uBAAuBA,CAAC3C,SAAS,EAAEmF,YAAY,EAAE;IAC/C,MAAMC,eAAe,GAAGpF,SAAS,GAAGmF,YAAY;IAChD,OAAOC,eAAe,GAAG,IAAI,GAAG,MAAM,GAAGA,eAAe,GAAG,IAAI,GAAG,QAAQ,GAAG,KAAK;EACpF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}