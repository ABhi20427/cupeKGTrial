{"ast":null,"code":"// cupe-kg-frontend/src/utils/enhancedRoutePlanner.js\n// FIXED VERSION - Replace your entire enhancedRoutePlanner.js with this\n\nexport class UltraAccurateRoutePlanner {\n  constructor(locations, routes) {\n    this.locations = locations || [];\n    this.routes = routes || [];\n\n    // Real distance matrix (in km) between major Indian cities\n    this.realDistanceMatrix = {\n      'delhi': {\n        'jaipur': 280,\n        'agra': 233,\n        'varanasi': 821,\n        'amritsar': 460,\n        'hampi': 1483,\n        'udaipur': 421,\n        'khajuraho': 620,\n        'bodh-gaya': 1105\n      },\n      'jaipur': {\n        'delhi': 280,\n        'udaipur': 393,\n        'taj-mahal': 240,\n        'ajanta': 739\n      },\n      'taj-mahal': {\n        'delhi': 233,\n        'jaipur': 240,\n        'khajuraho': 295,\n        'varanasi': 605\n      },\n      'varanasi': {\n        'delhi': 821,\n        'bodh-gaya': 250,\n        'khajuraho': 298,\n        'kolkata': 679,\n        'agra': 605\n      },\n      'bodh-gaya': {\n        'varanasi': 250,\n        'delhi': 1105,\n        'kolkata': 495,\n        'patna': 135\n      },\n      'hampi': {\n        'delhi': 1483,\n        'madurai': 440\n      },\n      'madurai': {\n        'hampi': 440,\n        'chennai': 462,\n        'bangalore': 460,\n        'kochi': 257\n      },\n      'amritsar': {\n        'delhi': 460,\n        'chandigarh': 230,\n        'shimla': 350\n      },\n      'udaipur': {\n        'jaipur': 393,\n        'delhi': 421,\n        'mumbai': 734,\n        'ajanta': 451\n      },\n      'konark': {\n        'bhubaneswar': 65,\n        'kolkata': 380,\n        'delhi': 1108\n      },\n      'ajanta': {\n        'ellora': 95,\n        'mumbai': 440,\n        'pune': 240,\n        'udaipur': 451\n      },\n      'ellora': {\n        'ajanta': 95,\n        'mumbai': 380,\n        'pune': 220\n      }\n    };\n\n    // Transportation costs (INR per km)\n    this.transportationCosts = {\n      'flight': 3.5,\n      'train': 0.75,\n      'bus': 0.45,\n      'car': 12\n    };\n\n    // Accommodation costs by city (per night)\n    this.accommodationCosts = {\n      'delhi': {\n        low: 1200,\n        medium: 3500,\n        high: 8500\n      },\n      'jaipur': {\n        low: 800,\n        medium: 2500,\n        high: 6500\n      },\n      'taj-mahal': {\n        low: 900,\n        medium: 2800,\n        high: 7000\n      },\n      'varanasi': {\n        low: 600,\n        medium: 1800,\n        high: 4500\n      },\n      'amritsar': {\n        low: 700,\n        medium: 2000,\n        high: 5000\n      },\n      'udaipur': {\n        low: 1000,\n        medium: 3200,\n        high: 8000\n      },\n      'hampi': {\n        low: 500,\n        medium: 1500,\n        high: 3500\n      },\n      'madurai': {\n        low: 600,\n        medium: 1800,\n        high: 4000\n      },\n      'bodh-gaya': {\n        low: 400,\n        medium: 1200,\n        high: 2800\n      },\n      'konark': {\n        low: 600,\n        medium: 1600,\n        high: 3500\n      },\n      'mahabalipuram': {\n        low: 800,\n        medium: 2200,\n        high: 5500\n      },\n      'ajanta': {\n        low: 600,\n        medium: 1600,\n        high: 3800\n      },\n      'ellora': {\n        low: 600,\n        medium: 1600,\n        high: 3800\n      },\n      'khajuraho': {\n        low: 700,\n        medium: 2000,\n        high: 4500\n      }\n    };\n\n    // Weather and seasonal data\n    this.seasonalData = {\n      'winter': {\n        months: ['Oct', 'Nov', 'Dec', 'Jan', 'Feb', 'Mar'],\n        bestRegions: ['north', 'central', 'west', 'south'],\n        temperature: {\n          min: 10,\n          max: 25\n        },\n        rainfall: 'minimal'\n      },\n      'summer': {\n        months: ['Apr', 'May', 'Jun'],\n        bestRegions: ['hills', 'north-east'],\n        avoidRegions: ['rajasthan', 'central'],\n        temperature: {\n          min: 25,\n          max: 45\n        },\n        rainfall: 'none'\n      },\n      'monsoon': {\n        months: ['Jul', 'Aug', 'Sep'],\n        bestRegions: ['western-ghats', 'caves'],\n        temperature: {\n          min: 20,\n          max: 30\n        },\n        rainfall: 'heavy'\n      }\n    };\n  }\n\n  // Main route creation function\n  createUltraAccurateRoute(preferences) {\n    console.log('Creating ultra-accurate route with preferences:', preferences);\n    const {\n      interests = [],\n      max_travel_days = 7,\n      budget_range = 'medium',\n      start_location = null,\n      transport_mode = 'car',\n      max_distance_km = 500\n    } = preferences;\n\n    // Step 1: Filter locations by interests\n    let candidateLocations = this.filterLocationsByInterests(interests);\n    console.log('Candidate locations found:', candidateLocations.length);\n    if (candidateLocations.length === 0) {\n      throw new Error('No locations found matching your interests');\n    }\n\n    // Step 2: Filter locations by distance from start location\n    if (start_location && max_distance_km) {\n      candidateLocations = this.filterLocationsByDistance(candidateLocations, start_location, max_distance_km);\n      console.log(`Locations within ${max_distance_km}km:`, candidateLocations.length);\n      if (candidateLocations.length === 0) {\n        throw new Error(`No locations found within ${max_distance_km}km of your starting point. Try increasing the distance limit.`);\n      }\n    }\n\n    // Step 3: Create optimized path\n    const optimizedPath = this.optimizePath(candidateLocations, start_location, max_travel_days, max_distance_km);\n    console.log('Optimized path created:', optimizedPath.length, 'locations');\n    if (optimizedPath.length === 0) {\n      throw new Error('Could not create an optimized path with your preferences');\n    }\n\n    // Step 4: Generate detailed itinerary\n    const detailedItinerary = this.createDetailedItinerary(optimizedPath, transport_mode, budget_range);\n    return detailedItinerary;\n  }\n\n  // Filter locations based on interests\n  filterLocationsByInterests(interests) {\n    if (!interests || interests.length === 0) {\n      return this.locations.slice(0, 8); // Return first 8 locations as default\n    }\n    const filteredLocations = this.locations.filter(location => {\n      const locationTags = location.tags || [];\n      const locationCategory = location.category || '';\n      const locationDescription = location.description || '';\n      return interests.some(interest => {\n        return locationTags.some(tag => tag.toLowerCase().includes(interest.toLowerCase())) || locationCategory.toLowerCase().includes(interest.toLowerCase()) || locationDescription.toLowerCase().includes(interest.toLowerCase());\n      });\n    });\n\n    // If filtered results are too few, add some popular destinations\n    if (filteredLocations.length < 3) {\n      const popularDestinations = this.locations.filter(loc => ['taj-mahal', 'delhi', 'jaipur', 'varanasi', 'hampi'].includes(loc.id));\n      return [...filteredLocations, ...popularDestinations].slice(0, 8);\n    }\n    return filteredLocations.slice(0, 10);\n  }\n\n  // Filter locations by distance from start point\n  filterLocationsByDistance(locations, startLocation, maxDistanceKm) {\n    if (!startLocation || !maxDistanceKm) {\n      return locations;\n    }\n    const filtered = locations.filter(location => {\n      const locationCoords = this.getLocationCoordinates(location);\n      const distance = this.calculateHaversineDistance(startLocation, locationCoords);\n      console.log(`Distance from start to ${location.name}: ${distance}km (max: ${maxDistanceKm}km)`);\n      return distance <= maxDistanceKm;\n    });\n    return filtered;\n  }\n\n  // Optimize path based on distance and travel time\n  optimizePath(locations, startLocation, maxDays, maxDistanceKm = null) {\n    if (!locations || locations.length === 0) {\n      return [];\n    }\n\n    // Limit locations based on travel days (roughly 1-2 locations per day)\n    const maxLocations = Math.min(locations.length, Math.ceil(maxDays / 1.5));\n    const limitedLocations = locations.slice(0, maxLocations);\n    if (limitedLocations.length <= 1) {\n      return limitedLocations;\n    }\n\n    // Simple nearest neighbor optimization\n    const optimizedPath = [];\n    const remainingLocations = [...limitedLocations];\n\n    // Start with location closest to start point or first location\n    let currentLocation;\n    if (startLocation) {\n      currentLocation = this.findNearestLocation(remainingLocations, startLocation);\n    } else {\n      currentLocation = remainingLocations[0];\n    }\n    optimizedPath.push(currentLocation);\n    const currentIndex = remainingLocations.indexOf(currentLocation);\n    remainingLocations.splice(currentIndex, 1);\n\n    // Add nearest neighbors, ensuring we don't exceed max distance from start\n    while (remainingLocations.length > 0 && optimizedPath.length < maxLocations) {\n      const currentCoords = this.getLocationCoordinates(currentLocation);\n      let nearestLocation = null;\n      let shortestDistance = Infinity;\n      remainingLocations.forEach(loc => {\n        const locCoords = this.getLocationCoordinates(loc);\n        const distance = this.calculateHaversineDistance(currentCoords, locCoords);\n\n        // Additional check: ensure location is within max distance from start if specified\n        if (maxDistanceKm && startLocation) {\n          const distanceFromStart = this.calculateHaversineDistance(startLocation, locCoords);\n          if (distanceFromStart > maxDistanceKm) {\n            return; // Skip this location as it's beyond max distance\n          }\n        }\n        if (distance < shortestDistance) {\n          shortestDistance = distance;\n          nearestLocation = loc;\n        }\n      });\n      if (nearestLocation) {\n        optimizedPath.push(nearestLocation);\n        currentLocation = nearestLocation;\n        const nearestIndex = remainingLocations.indexOf(nearestLocation);\n        remainingLocations.splice(nearestIndex, 1);\n      } else {\n        break;\n      }\n    }\n    return optimizedPath;\n  }\n\n  // Find nearest location to a given point\n  findNearestLocation(locations, point) {\n    let nearest = locations[0];\n    let shortestDistance = Infinity;\n    locations.forEach(location => {\n      const locCoords = this.getLocationCoordinates(location);\n      const distance = this.calculateHaversineDistance(point, locCoords);\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        nearest = location;\n      }\n    });\n    return nearest;\n  }\n\n  // Get coordinates from location object\n  getLocationCoordinates(location) {\n    if (location.coordinates) {\n      if (typeof location.coordinates === 'object' && location.coordinates.lat) {\n        return {\n          lat: location.coordinates.lat,\n          lng: location.coordinates.lng\n        };\n      } else if (Array.isArray(location.coordinates)) {\n        return {\n          lat: location.coordinates[0],\n          lng: location.coordinates[1]\n        };\n      }\n    }\n\n    // Fallback coordinates if not available\n    return {\n      lat: 28.6139,\n      lng: 77.2090\n    }; // Delhi coordinates as fallback\n  }\n\n  // Calculate Haversine distance\n  calculateHaversineDistance(coord1, coord2) {\n    const R = 6371; // Earth's radius in km\n    const lat1 = coord1.lat || coord1[0] || 0;\n    const lng1 = coord1.lng || coord1[1] || 0;\n    const lat2 = coord2.lat || coord2[0] || 0;\n    const lng2 = coord2.lng || coord2[1] || 0;\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return Math.round(R * c);\n  }\n\n  // Create detailed itinerary\n  createDetailedItinerary(path, transportMode, budget) {\n    const itinerary = [];\n    let currentDay = 1;\n    let totalCost = 0;\n    for (let i = 0; i < path.length; i++) {\n      const location = path[i];\n      const nextLocation = path[i + 1];\n\n      // Location exploration days - THIS IS THE MISSING METHOD\n      const daysAtLocation = this.getOptimalDaysAtLocation(location);\n      const dailyCost = this.getAccommodationCost(location.id || location.name, budget) + this.getFoodCost(budget) + this.getLocalTransportCost();\n      for (let day = 0; day < daysAtLocation; day++) {\n        const dayActivity = this.generateDayActivity(location, day, budget);\n        itinerary.push({\n          day: currentDay + day,\n          location: location.name,\n          type: 'exploration',\n          description: dayActivity.description,\n          highlights: dayActivity.highlights,\n          costs: {\n            accommodation: this.getAccommodationCost(location.id || location.name, budget),\n            food: this.getFoodCost(budget),\n            localTransport: this.getLocalTransportCost(),\n            attractions: dayActivity.attractionCosts,\n            total: dailyCost + dayActivity.attractionCosts\n          },\n          culturalInsights: this.getCulturalInsights(location),\n          practicalTips: this.getPracticalTips(location)\n        });\n        totalCost += dailyCost + dayActivity.attractionCosts;\n      }\n      currentDay += daysAtLocation;\n\n      // Travel day\n      if (nextLocation) {\n        const travelDetails = this.getAccurateTravelDetails(location, nextLocation, transportMode);\n        itinerary.push({\n          day: currentDay,\n          location: `${location.name} to ${nextLocation.name}`,\n          type: 'travel',\n          description: `Travel from ${location.name} to ${nextLocation.name} via ${travelDetails.mode}`,\n          travelDetails: travelDetails,\n          costs: {\n            transport: travelDetails.cost,\n            food: travelDetails.mealCost || 0,\n            total: travelDetails.cost + (travelDetails.mealCost || 0)\n          }\n        });\n        totalCost += travelDetails.cost + (travelDetails.mealCost || 0);\n        currentDay++;\n      }\n    }\n    return {\n      id: `ultra-accurate-${Date.now()}`,\n      name: 'Your Culturally Intelligent Route',\n      description: `Scientifically optimized ${path.length}-destination route with cultural depth`,\n      color: '#2196F3',\n      path: path.map(loc => {\n        const coords = this.getLocationCoordinates(loc);\n        return [coords.lat, coords.lng];\n      }),\n      locations: path.map(loc => {\n        const coords = this.getLocationCoordinates(loc);\n        return {\n          name: loc.name,\n          coordinates: [coords.lat, coords.lng],\n          description: loc.description || 'Cultural heritage site'\n        };\n      }),\n      detailedItinerary: itinerary,\n      totalCost: Math.round(totalCost),\n      totalDays: currentDay - 1,\n      culturalThemes: this.extractCulturalThemes(path),\n      optimizationMetrics: {\n        totalDistance: this.calculateTotalDistance(path),\n        culturalDiversity: this.calculateCulturalDiversity(path),\n        costEfficiency: this.calculateCostEfficiency(totalCost, path.length)\n      }\n    };\n  }\n\n  // THE MISSING METHOD - Calculate optimal days at each location\n  getOptimalDaysAtLocation(location) {\n    var _location$name;\n    // Default to 2 days, but adjust based on location importance and attractions\n    const locationName = ((_location$name = location.name) === null || _location$name === void 0 ? void 0 : _location$name.toLowerCase()) || '';\n\n    // Major destinations that need more time\n    const majorDestinations = ['delhi', 'rajasthan', 'taj mahal', 'varanasi', 'hampi'];\n    if (majorDestinations.some(dest => locationName.includes(dest))) {\n      return 3;\n    }\n\n    // UNESCO sites or complex sites\n    const complexSites = ['ajanta', 'ellora', 'khajuraho', 'konark'];\n    if (complexSites.some(site => locationName.includes(site))) {\n      return 2;\n    }\n\n    // Default for most locations\n    return 2;\n  }\n\n  // Helper methods for accurate cost calculation\n  getAccommodationCost(locationId, budget) {\n    const normalizedId = (locationId === null || locationId === void 0 ? void 0 : locationId.toLowerCase().replace(/\\s+/g, '-')) || 'default';\n    const costs = this.accommodationCosts[normalizedId] || {\n      low: 800,\n      medium: 2500,\n      high: 6000\n    };\n    return costs[budget] || costs.medium;\n  }\n  getFoodCost(budget) {\n    const foodCosts = {\n      low: 800,\n      medium: 1500,\n      high: 3000\n    };\n    return foodCosts[budget] || foodCosts.medium;\n  }\n  getLocalTransportCost() {\n    return 500; // Average local transport per day\n  }\n\n  // Generate detailed day activities\n  generateDayActivity(location, dayNumber, budget) {\n    const attractions = this.getLocationAttractions(location.id || location.name);\n    const selectedAttractions = attractions.slice(dayNumber * 2, (dayNumber + 1) * 2);\n    return {\n      description: `Day ${dayNumber + 1} in ${location.name}: ${selectedAttractions.map(a => a.name).join(', ')}`,\n      highlights: selectedAttractions,\n      attractionCosts: selectedAttractions.reduce((sum, attr) => sum + (attr.entryCost || 0), 0)\n    };\n  }\n\n  // Get location-specific attractions with costs\n  getLocationAttractions(locationId) {\n    const attractions = {\n      'delhi': [{\n        name: 'Red Fort',\n        entryCost: 35,\n        time: '3 hours'\n      }, {\n        name: 'India Gate',\n        entryCost: 0,\n        time: '1 hour'\n      }, {\n        name: 'Qutub Minar',\n        entryCost: 30,\n        time: '2 hours'\n      }, {\n        name: 'Lotus Temple',\n        entryCost: 0,\n        time: '1 hour'\n      }],\n      'taj-mahal': [{\n        name: 'Taj Mahal',\n        entryCost: 50,\n        time: '4 hours'\n      }, {\n        name: 'Agra Fort',\n        entryCost: 40,\n        time: '3 hours'\n      }, {\n        name: 'Mehtab Bagh',\n        entryCost: 25,\n        time: '2 hours'\n      }],\n      'jaipur': [{\n        name: 'Amber Fort',\n        entryCost: 25,\n        time: '4 hours'\n      }, {\n        name: 'City Palace',\n        entryCost: 30,\n        time: '3 hours'\n      }, {\n        name: 'Hawa Mahal',\n        entryCost: 15,\n        time: '1 hour'\n      }]\n    };\n    const normalizedId = (locationId === null || locationId === void 0 ? void 0 : locationId.toLowerCase().replace(/\\s+/g, '-')) || 'default';\n    return attractions[normalizedId] || [{\n      name: 'Main Attraction',\n      entryCost: 25,\n      time: '3 hours'\n    }, {\n      name: 'Local Temple',\n      entryCost: 10,\n      time: '2 hours'\n    }, {\n      name: 'Cultural Site',\n      entryCost: 20,\n      time: '2 hours'\n    }];\n  }\n\n  // Get accurate travel details between locations\n  getAccurateTravelDetails(from, to, mode) {\n    const fromCoords = this.getLocationCoordinates(from);\n    const toCoords = this.getLocationCoordinates(to);\n    const distance = this.calculateHaversineDistance(fromCoords, toCoords);\n    const transportMode = mode || 'car';\n    const costPerKm = this.transportationCosts[transportMode] || this.transportationCosts.car;\n    const baseCost = distance * costPerKm;\n\n    // Calculate travel time based on mode\n    const speeds = {\n      car: 60,\n      train: 80,\n      bus: 50,\n      flight: 500\n    }; // km/h\n    const speed = speeds[transportMode] || speeds.car;\n    const travelTimeHours = Math.ceil(distance / speed);\n    return {\n      mode: transportMode,\n      distance: distance,\n      duration: `${travelTimeHours} hours`,\n      cost: Math.round(baseCost),\n      mealCost: travelTimeHours > 4 ? 300 : 0\n    };\n  }\n\n  // Get cultural insights for location\n  getCulturalInsights(location) {\n    return [`Rich cultural heritage dating back centuries`, `Architectural significance in ${location.dynasty || 'regional'} style`, `Important pilgrimage and tourism destination`];\n  }\n\n  // Get practical tips\n  getPracticalTips(location) {\n    return ['Best visited early morning or late afternoon', 'Respect local customs and dress codes', 'Hire local guides for deeper insights', 'Carry water and comfortable walking shoes'];\n  }\n\n  // Extract cultural themes from path\n  extractCulturalThemes(path) {\n    const themes = new Set();\n    path.forEach(location => {\n      if (location.dynasty) themes.add(location.dynasty);\n      if (location.category) themes.add(location.category);\n      if (location.tags) location.tags.forEach(tag => themes.add(tag));\n    });\n    return Array.from(themes);\n  }\n\n  // Calculate total distance\n  calculateTotalDistance(path) {\n    let totalDistance = 0;\n    for (let i = 0; i < path.length - 1; i++) {\n      const current = this.getLocationCoordinates(path[i]);\n      const next = this.getLocationCoordinates(path[i + 1]);\n      totalDistance += this.calculateHaversineDistance(current, next);\n    }\n    return totalDistance;\n  }\n\n  // Calculate cultural diversity score\n  calculateCulturalDiversity(path) {\n    const themes = this.extractCulturalThemes(path);\n    return Math.min(themes.length * 10, 100); // Max 100%\n  }\n\n  // Calculate cost efficiency\n  calculateCostEfficiency(totalCost, numLocations) {\n    const costPerLocation = totalCost / numLocations;\n    return costPerLocation < 5000 ? 'High' : costPerLocation < 8000 ? 'Medium' : 'Low';\n  }\n}","map":{"version":3,"names":["UltraAccurateRoutePlanner","constructor","locations","routes","realDistanceMatrix","transportationCosts","accommodationCosts","low","medium","high","seasonalData","months","bestRegions","temperature","min","max","rainfall","avoidRegions","createUltraAccurateRoute","preferences","console","log","interests","max_travel_days","budget_range","start_location","transport_mode","max_distance_km","candidateLocations","filterLocationsByInterests","length","Error","filterLocationsByDistance","optimizedPath","optimizePath","detailedItinerary","createDetailedItinerary","slice","filteredLocations","filter","location","locationTags","tags","locationCategory","category","locationDescription","description","some","interest","tag","toLowerCase","includes","popularDestinations","loc","id","startLocation","maxDistanceKm","filtered","locationCoords","getLocationCoordinates","distance","calculateHaversineDistance","name","maxDays","maxLocations","Math","ceil","limitedLocations","remainingLocations","currentLocation","findNearestLocation","push","currentIndex","indexOf","splice","currentCoords","nearestLocation","shortestDistance","Infinity","forEach","locCoords","distanceFromStart","nearestIndex","point","nearest","coordinates","lat","lng","Array","isArray","coord1","coord2","R","lat1","lng1","lat2","lng2","dLat","PI","dLng","a","sin","cos","c","atan2","sqrt","round","path","transportMode","budget","itinerary","currentDay","totalCost","i","nextLocation","daysAtLocation","getOptimalDaysAtLocation","dailyCost","getAccommodationCost","getFoodCost","getLocalTransportCost","day","dayActivity","generateDayActivity","type","highlights","costs","accommodation","food","localTransport","attractions","attractionCosts","total","culturalInsights","getCulturalInsights","practicalTips","getPracticalTips","travelDetails","getAccurateTravelDetails","mode","transport","cost","mealCost","Date","now","color","map","coords","totalDays","culturalThemes","extractCulturalThemes","optimizationMetrics","totalDistance","calculateTotalDistance","culturalDiversity","calculateCulturalDiversity","costEfficiency","calculateCostEfficiency","_location$name","locationName","majorDestinations","dest","complexSites","site","locationId","normalizedId","replace","foodCosts","dayNumber","getLocationAttractions","selectedAttractions","join","reduce","sum","attr","entryCost","time","from","to","fromCoords","toCoords","costPerKm","car","baseCost","speeds","train","bus","flight","speed","travelTimeHours","duration","dynasty","themes","Set","add","current","next","numLocations","costPerLocation"],"sources":["D:/MY projects/CupeKG/cupe-kg-frontend/src/utils/enhancedRoutePlanner.js"],"sourcesContent":["// cupe-kg-frontend/src/utils/enhancedRoutePlanner.js\r\n// FIXED VERSION - Replace your entire enhancedRoutePlanner.js with this\r\n\r\nexport class UltraAccurateRoutePlanner {\r\n  constructor(locations, routes) {\r\n    this.locations = locations || [];\r\n    this.routes = routes || [];\r\n    \r\n    // Real distance matrix (in km) between major Indian cities\r\n    this.realDistanceMatrix = {\r\n      'delhi': {\r\n        'jaipur': 280, 'agra': 233, 'varanasi': 821, 'amritsar': 460,\r\n        'hampi': 1483, 'udaipur': 421, 'khajuraho': 620, 'bodh-gaya': 1105\r\n      },\r\n      'jaipur': {\r\n        'delhi': 280, 'udaipur': 393, 'taj-mahal': 240, 'ajanta': 739\r\n      },\r\n      'taj-mahal': {\r\n        'delhi': 233, 'jaipur': 240, 'khajuraho': 295, 'varanasi': 605\r\n      },\r\n      'varanasi': {\r\n        'delhi': 821, 'bodh-gaya': 250, 'khajuraho': 298, 'kolkata': 679,\r\n        'agra': 605\r\n      },\r\n      'bodh-gaya': {\r\n        'varanasi': 250, 'delhi': 1105, 'kolkata': 495, 'patna': 135\r\n      },\r\n      'hampi': {\r\n        'delhi': 1483, 'madurai': 440\r\n      },\r\n      'madurai': {\r\n        'hampi': 440, 'chennai': 462, 'bangalore': 460, 'kochi': 257\r\n      },\r\n      'amritsar': {\r\n        'delhi': 460, 'chandigarh': 230, 'shimla': 350\r\n      },\r\n      'udaipur': {\r\n        'jaipur': 393, 'delhi': 421, 'mumbai': 734, 'ajanta': 451\r\n      },\r\n      'konark': {\r\n        'bhubaneswar': 65, 'kolkata': 380, 'delhi': 1108\r\n      },\r\n      'ajanta': {\r\n        'ellora': 95, 'mumbai': 440, 'pune': 240, 'udaipur': 451\r\n      },\r\n      'ellora': {\r\n        'ajanta': 95, 'mumbai': 380, 'pune': 220\r\n      }\r\n    };\r\n\r\n    // Transportation costs (INR per km)\r\n    this.transportationCosts = {\r\n      'flight': 3.5,\r\n      'train': 0.75,\r\n      'bus': 0.45,\r\n      'car': 12\r\n    };\r\n\r\n    // Accommodation costs by city (per night)\r\n    this.accommodationCosts = {\r\n      'delhi': { low: 1200, medium: 3500, high: 8500 },\r\n      'jaipur': { low: 800, medium: 2500, high: 6500 },\r\n      'taj-mahal': { low: 900, medium: 2800, high: 7000 },\r\n      'varanasi': { low: 600, medium: 1800, high: 4500 },\r\n      'amritsar': { low: 700, medium: 2000, high: 5000 },\r\n      'udaipur': { low: 1000, medium: 3200, high: 8000 },\r\n      'hampi': { low: 500, medium: 1500, high: 3500 },\r\n      'madurai': { low: 600, medium: 1800, high: 4000 },\r\n      'bodh-gaya': { low: 400, medium: 1200, high: 2800 },\r\n      'konark': { low: 600, medium: 1600, high: 3500 },\r\n      'mahabalipuram': { low: 800, medium: 2200, high: 5500 },\r\n      'ajanta': { low: 600, medium: 1600, high: 3800 },\r\n      'ellora': { low: 600, medium: 1600, high: 3800 },\r\n      'khajuraho': { low: 700, medium: 2000, high: 4500 }\r\n    };\r\n\r\n    // Weather and seasonal data\r\n    this.seasonalData = {\r\n      'winter': {\r\n        months: ['Oct', 'Nov', 'Dec', 'Jan', 'Feb', 'Mar'],\r\n        bestRegions: ['north', 'central', 'west', 'south'],\r\n        temperature: { min: 10, max: 25 },\r\n        rainfall: 'minimal'\r\n      },\r\n      'summer': {\r\n        months: ['Apr', 'May', 'Jun'],\r\n        bestRegions: ['hills', 'north-east'],\r\n        avoidRegions: ['rajasthan', 'central'],\r\n        temperature: { min: 25, max: 45 },\r\n        rainfall: 'none'\r\n      },\r\n      'monsoon': {\r\n        months: ['Jul', 'Aug', 'Sep'],\r\n        bestRegions: ['western-ghats', 'caves'],\r\n        temperature: { min: 20, max: 30 },\r\n        rainfall: 'heavy'\r\n      }\r\n    };\r\n  }\r\n\r\n  // Main route creation function\r\n  createUltraAccurateRoute(preferences) {\r\n    console.log('Creating ultra-accurate route with preferences:', preferences);\r\n\r\n    const {\r\n      interests = [],\r\n      max_travel_days = 7,\r\n      budget_range = 'medium',\r\n      start_location = null,\r\n      transport_mode = 'car',\r\n      max_distance_km = 500\r\n    } = preferences;\r\n\r\n    // Step 1: Filter locations by interests\r\n    let candidateLocations = this.filterLocationsByInterests(interests);\r\n    console.log('Candidate locations found:', candidateLocations.length);\r\n\r\n    if (candidateLocations.length === 0) {\r\n      throw new Error('No locations found matching your interests');\r\n    }\r\n\r\n    // Step 2: Filter locations by distance from start location\r\n    if (start_location && max_distance_km) {\r\n      candidateLocations = this.filterLocationsByDistance(candidateLocations, start_location, max_distance_km);\r\n      console.log(`Locations within ${max_distance_km}km:`, candidateLocations.length);\r\n\r\n      if (candidateLocations.length === 0) {\r\n        throw new Error(`No locations found within ${max_distance_km}km of your starting point. Try increasing the distance limit.`);\r\n      }\r\n    }\r\n\r\n    // Step 3: Create optimized path\r\n    const optimizedPath = this.optimizePath(candidateLocations, start_location, max_travel_days, max_distance_km);\r\n    console.log('Optimized path created:', optimizedPath.length, 'locations');\r\n\r\n    if (optimizedPath.length === 0) {\r\n      throw new Error('Could not create an optimized path with your preferences');\r\n    }\r\n\r\n    // Step 4: Generate detailed itinerary\r\n    const detailedItinerary = this.createDetailedItinerary(optimizedPath, transport_mode, budget_range);\r\n\r\n    return detailedItinerary;\r\n  }\r\n\r\n  // Filter locations based on interests\r\n  filterLocationsByInterests(interests) {\r\n    if (!interests || interests.length === 0) {\r\n      return this.locations.slice(0, 8); // Return first 8 locations as default\r\n    }\r\n\r\n    const filteredLocations = this.locations.filter(location => {\r\n      const locationTags = location.tags || [];\r\n      const locationCategory = location.category || '';\r\n      const locationDescription = location.description || '';\r\n\r\n      return interests.some(interest => {\r\n        return locationTags.some(tag => tag.toLowerCase().includes(interest.toLowerCase())) ||\r\n               locationCategory.toLowerCase().includes(interest.toLowerCase()) ||\r\n               locationDescription.toLowerCase().includes(interest.toLowerCase());\r\n      });\r\n    });\r\n\r\n    // If filtered results are too few, add some popular destinations\r\n    if (filteredLocations.length < 3) {\r\n      const popularDestinations = this.locations.filter(loc =>\r\n        ['taj-mahal', 'delhi', 'jaipur', 'varanasi', 'hampi'].includes(loc.id)\r\n      );\r\n      return [...filteredLocations, ...popularDestinations].slice(0, 8);\r\n    }\r\n\r\n    return filteredLocations.slice(0, 10);\r\n  }\r\n\r\n  // Filter locations by distance from start point\r\n  filterLocationsByDistance(locations, startLocation, maxDistanceKm) {\r\n    if (!startLocation || !maxDistanceKm) {\r\n      return locations;\r\n    }\r\n\r\n    const filtered = locations.filter(location => {\r\n      const locationCoords = this.getLocationCoordinates(location);\r\n      const distance = this.calculateHaversineDistance(startLocation, locationCoords);\r\n\r\n      console.log(`Distance from start to ${location.name}: ${distance}km (max: ${maxDistanceKm}km)`);\r\n\r\n      return distance <= maxDistanceKm;\r\n    });\r\n\r\n    return filtered;\r\n  }\r\n\r\n  // Optimize path based on distance and travel time\r\n  optimizePath(locations, startLocation, maxDays, maxDistanceKm = null) {\r\n    if (!locations || locations.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    // Limit locations based on travel days (roughly 1-2 locations per day)\r\n    const maxLocations = Math.min(locations.length, Math.ceil(maxDays / 1.5));\r\n    const limitedLocations = locations.slice(0, maxLocations);\r\n\r\n    if (limitedLocations.length <= 1) {\r\n      return limitedLocations;\r\n    }\r\n\r\n    // Simple nearest neighbor optimization\r\n    const optimizedPath = [];\r\n    const remainingLocations = [...limitedLocations];\r\n\r\n    // Start with location closest to start point or first location\r\n    let currentLocation;\r\n    if (startLocation) {\r\n      currentLocation = this.findNearestLocation(remainingLocations, startLocation);\r\n    } else {\r\n      currentLocation = remainingLocations[0];\r\n    }\r\n\r\n    optimizedPath.push(currentLocation);\r\n    const currentIndex = remainingLocations.indexOf(currentLocation);\r\n    remainingLocations.splice(currentIndex, 1);\r\n\r\n    // Add nearest neighbors, ensuring we don't exceed max distance from start\r\n    while (remainingLocations.length > 0 && optimizedPath.length < maxLocations) {\r\n      const currentCoords = this.getLocationCoordinates(currentLocation);\r\n      let nearestLocation = null;\r\n      let shortestDistance = Infinity;\r\n\r\n      remainingLocations.forEach(loc => {\r\n        const locCoords = this.getLocationCoordinates(loc);\r\n        const distance = this.calculateHaversineDistance(currentCoords, locCoords);\r\n\r\n        // Additional check: ensure location is within max distance from start if specified\r\n        if (maxDistanceKm && startLocation) {\r\n          const distanceFromStart = this.calculateHaversineDistance(startLocation, locCoords);\r\n          if (distanceFromStart > maxDistanceKm) {\r\n            return; // Skip this location as it's beyond max distance\r\n          }\r\n        }\r\n\r\n        if (distance < shortestDistance) {\r\n          shortestDistance = distance;\r\n          nearestLocation = loc;\r\n        }\r\n      });\r\n\r\n      if (nearestLocation) {\r\n        optimizedPath.push(nearestLocation);\r\n        currentLocation = nearestLocation;\r\n        const nearestIndex = remainingLocations.indexOf(nearestLocation);\r\n        remainingLocations.splice(nearestIndex, 1);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return optimizedPath;\r\n  }\r\n\r\n  // Find nearest location to a given point\r\n  findNearestLocation(locations, point) {\r\n    let nearest = locations[0];\r\n    let shortestDistance = Infinity;\r\n\r\n    locations.forEach(location => {\r\n      const locCoords = this.getLocationCoordinates(location);\r\n      const distance = this.calculateHaversineDistance(point, locCoords);\r\n      \r\n      if (distance < shortestDistance) {\r\n        shortestDistance = distance;\r\n        nearest = location;\r\n      }\r\n    });\r\n\r\n    return nearest;\r\n  }\r\n\r\n  // Get coordinates from location object\r\n  getLocationCoordinates(location) {\r\n    if (location.coordinates) {\r\n      if (typeof location.coordinates === 'object' && location.coordinates.lat) {\r\n        return { lat: location.coordinates.lat, lng: location.coordinates.lng };\r\n      } else if (Array.isArray(location.coordinates)) {\r\n        return { lat: location.coordinates[0], lng: location.coordinates[1] };\r\n      }\r\n    }\r\n    \r\n    // Fallback coordinates if not available\r\n    return { lat: 28.6139, lng: 77.2090 }; // Delhi coordinates as fallback\r\n  }\r\n\r\n  // Calculate Haversine distance\r\n  calculateHaversineDistance(coord1, coord2) {\r\n    const R = 6371; // Earth's radius in km\r\n    const lat1 = coord1.lat || coord1[0] || 0;\r\n    const lng1 = coord1.lng || coord1[1] || 0;\r\n    const lat2 = coord2.lat || coord2[0] || 0;\r\n    const lng2 = coord2.lng || coord2[1] || 0;\r\n    \r\n    const dLat = (lat2 - lat1) * Math.PI / 180;\r\n    const dLng = (lng2 - lng1) * Math.PI / 180;\r\n    \r\n    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\r\n              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\r\n              Math.sin(dLng/2) * Math.sin(dLng/2);\r\n    \r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\r\n    return Math.round(R * c);\r\n  }\r\n\r\n  // Create detailed itinerary\r\n  createDetailedItinerary(path, transportMode, budget) {\r\n    const itinerary = [];\r\n    let currentDay = 1;\r\n    let totalCost = 0;\r\n    \r\n    for (let i = 0; i < path.length; i++) {\r\n      const location = path[i];\r\n      const nextLocation = path[i + 1];\r\n      \r\n      // Location exploration days - THIS IS THE MISSING METHOD\r\n      const daysAtLocation = this.getOptimalDaysAtLocation(location);\r\n      const dailyCost = this.getAccommodationCost(location.id || location.name, budget) + \r\n                       this.getFoodCost(budget) + \r\n                       this.getLocalTransportCost();\r\n      \r\n      for (let day = 0; day < daysAtLocation; day++) {\r\n        const dayActivity = this.generateDayActivity(location, day, budget);\r\n        itinerary.push({\r\n          day: currentDay + day,\r\n          location: location.name,\r\n          type: 'exploration',\r\n          description: dayActivity.description,\r\n          highlights: dayActivity.highlights,\r\n          costs: {\r\n            accommodation: this.getAccommodationCost(location.id || location.name, budget),\r\n            food: this.getFoodCost(budget),\r\n            localTransport: this.getLocalTransportCost(),\r\n            attractions: dayActivity.attractionCosts,\r\n            total: dailyCost + dayActivity.attractionCosts\r\n          },\r\n          culturalInsights: this.getCulturalInsights(location),\r\n          practicalTips: this.getPracticalTips(location)\r\n        });\r\n        totalCost += dailyCost + dayActivity.attractionCosts;\r\n      }\r\n      \r\n      currentDay += daysAtLocation;\r\n      \r\n      // Travel day\r\n      if (nextLocation) {\r\n        const travelDetails = this.getAccurateTravelDetails(location, nextLocation, transportMode);\r\n        itinerary.push({\r\n          day: currentDay,\r\n          location: `${location.name} to ${nextLocation.name}`,\r\n          type: 'travel',\r\n          description: `Travel from ${location.name} to ${nextLocation.name} via ${travelDetails.mode}`,\r\n          travelDetails: travelDetails,\r\n          costs: {\r\n            transport: travelDetails.cost,\r\n            food: travelDetails.mealCost || 0,\r\n            total: travelDetails.cost + (travelDetails.mealCost || 0)\r\n          }\r\n        });\r\n        totalCost += travelDetails.cost + (travelDetails.mealCost || 0);\r\n        currentDay++;\r\n      }\r\n    }\r\n    \r\n    return {\r\n      id: `ultra-accurate-${Date.now()}`,\r\n      name: 'Your Culturally Intelligent Route',\r\n      description: `Scientifically optimized ${path.length}-destination route with cultural depth`,\r\n      color: '#2196F3',\r\n      path: path.map(loc => {\r\n        const coords = this.getLocationCoordinates(loc);\r\n        return [coords.lat, coords.lng];\r\n      }),\r\n      locations: path.map(loc => {\r\n        const coords = this.getLocationCoordinates(loc);\r\n        return {\r\n          name: loc.name,\r\n          coordinates: [coords.lat, coords.lng],\r\n          description: loc.description || 'Cultural heritage site'\r\n        };\r\n      }),\r\n      detailedItinerary: itinerary,\r\n      totalCost: Math.round(totalCost),\r\n      totalDays: currentDay - 1,\r\n      culturalThemes: this.extractCulturalThemes(path),\r\n      optimizationMetrics: {\r\n        totalDistance: this.calculateTotalDistance(path),\r\n        culturalDiversity: this.calculateCulturalDiversity(path),\r\n        costEfficiency: this.calculateCostEfficiency(totalCost, path.length)\r\n      }\r\n    };\r\n  }\r\n\r\n  // THE MISSING METHOD - Calculate optimal days at each location\r\n  getOptimalDaysAtLocation(location) {\r\n    // Default to 2 days, but adjust based on location importance and attractions\r\n    const locationName = location.name?.toLowerCase() || '';\r\n    \r\n    // Major destinations that need more time\r\n    const majorDestinations = ['delhi', 'rajasthan', 'taj mahal', 'varanasi', 'hampi'];\r\n    if (majorDestinations.some(dest => locationName.includes(dest))) {\r\n      return 3;\r\n    }\r\n    \r\n    // UNESCO sites or complex sites\r\n    const complexSites = ['ajanta', 'ellora', 'khajuraho', 'konark'];\r\n    if (complexSites.some(site => locationName.includes(site))) {\r\n      return 2;\r\n    }\r\n    \r\n    // Default for most locations\r\n    return 2;\r\n  }\r\n\r\n  // Helper methods for accurate cost calculation\r\n  getAccommodationCost(locationId, budget) {\r\n    const normalizedId = locationId?.toLowerCase().replace(/\\s+/g, '-') || 'default';\r\n    const costs = this.accommodationCosts[normalizedId] || { low: 800, medium: 2500, high: 6000 };\r\n    return costs[budget] || costs.medium;\r\n  }\r\n\r\n  getFoodCost(budget) {\r\n    const foodCosts = { low: 800, medium: 1500, high: 3000 };\r\n    return foodCosts[budget] || foodCosts.medium;\r\n  }\r\n\r\n  getLocalTransportCost() {\r\n    return 500; // Average local transport per day\r\n  }\r\n\r\n  // Generate detailed day activities\r\n  generateDayActivity(location, dayNumber, budget) {\r\n    const attractions = this.getLocationAttractions(location.id || location.name);\r\n    const selectedAttractions = attractions.slice(dayNumber * 2, (dayNumber + 1) * 2);\r\n    \r\n    return {\r\n      description: `Day ${dayNumber + 1} in ${location.name}: ${selectedAttractions.map(a => a.name).join(', ')}`,\r\n      highlights: selectedAttractions,\r\n      attractionCosts: selectedAttractions.reduce((sum, attr) => sum + (attr.entryCost || 0), 0)\r\n    };\r\n  }\r\n\r\n  // Get location-specific attractions with costs\r\n  getLocationAttractions(locationId) {\r\n    const attractions = {\r\n      'delhi': [\r\n        { name: 'Red Fort', entryCost: 35, time: '3 hours' },\r\n        { name: 'India Gate', entryCost: 0, time: '1 hour' },\r\n        { name: 'Qutub Minar', entryCost: 30, time: '2 hours' },\r\n        { name: 'Lotus Temple', entryCost: 0, time: '1 hour' }\r\n      ],\r\n      'taj-mahal': [\r\n        { name: 'Taj Mahal', entryCost: 50, time: '4 hours' },\r\n        { name: 'Agra Fort', entryCost: 40, time: '3 hours' },\r\n        { name: 'Mehtab Bagh', entryCost: 25, time: '2 hours' }\r\n      ],\r\n      'jaipur': [\r\n        { name: 'Amber Fort', entryCost: 25, time: '4 hours' },\r\n        { name: 'City Palace', entryCost: 30, time: '3 hours' },\r\n        { name: 'Hawa Mahal', entryCost: 15, time: '1 hour' }\r\n      ]\r\n    };\r\n\r\n    const normalizedId = locationId?.toLowerCase().replace(/\\s+/g, '-') || 'default';\r\n    return attractions[normalizedId] || [\r\n      { name: 'Main Attraction', entryCost: 25, time: '3 hours' },\r\n      { name: 'Local Temple', entryCost: 10, time: '2 hours' },\r\n      { name: 'Cultural Site', entryCost: 20, time: '2 hours' }\r\n    ];\r\n  }\r\n\r\n  // Get accurate travel details between locations\r\n  getAccurateTravelDetails(from, to, mode) {\r\n    const fromCoords = this.getLocationCoordinates(from);\r\n    const toCoords = this.getLocationCoordinates(to);\r\n    const distance = this.calculateHaversineDistance(fromCoords, toCoords);\r\n    \r\n    const transportMode = mode || 'car';\r\n    const costPerKm = this.transportationCosts[transportMode] || this.transportationCosts.car;\r\n    const baseCost = distance * costPerKm;\r\n    \r\n    // Calculate travel time based on mode\r\n    const speeds = { car: 60, train: 80, bus: 50, flight: 500 }; // km/h\r\n    const speed = speeds[transportMode] || speeds.car;\r\n    const travelTimeHours = Math.ceil(distance / speed);\r\n    \r\n    return {\r\n      mode: transportMode,\r\n      distance: distance,\r\n      duration: `${travelTimeHours} hours`,\r\n      cost: Math.round(baseCost),\r\n      mealCost: travelTimeHours > 4 ? 300 : 0\r\n    };\r\n  }\r\n\r\n  // Get cultural insights for location\r\n  getCulturalInsights(location) {\r\n    return [\r\n      `Rich cultural heritage dating back centuries`,\r\n      `Architectural significance in ${location.dynasty || 'regional'} style`,\r\n      `Important pilgrimage and tourism destination`\r\n    ];\r\n  }\r\n\r\n  // Get practical tips\r\n  getPracticalTips(location) {\r\n    return [\r\n      'Best visited early morning or late afternoon',\r\n      'Respect local customs and dress codes',\r\n      'Hire local guides for deeper insights',\r\n      'Carry water and comfortable walking shoes'\r\n    ];\r\n  }\r\n\r\n  // Extract cultural themes from path\r\n  extractCulturalThemes(path) {\r\n    const themes = new Set();\r\n    path.forEach(location => {\r\n      if (location.dynasty) themes.add(location.dynasty);\r\n      if (location.category) themes.add(location.category);\r\n      if (location.tags) location.tags.forEach(tag => themes.add(tag));\r\n    });\r\n    return Array.from(themes);\r\n  }\r\n\r\n  // Calculate total distance\r\n  calculateTotalDistance(path) {\r\n    let totalDistance = 0;\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n      const current = this.getLocationCoordinates(path[i]);\r\n      const next = this.getLocationCoordinates(path[i + 1]);\r\n      totalDistance += this.calculateHaversineDistance(current, next);\r\n    }\r\n    return totalDistance;\r\n  }\r\n\r\n  // Calculate cultural diversity score\r\n  calculateCulturalDiversity(path) {\r\n    const themes = this.extractCulturalThemes(path);\r\n    return Math.min(themes.length * 10, 100); // Max 100%\r\n  }\r\n\r\n  // Calculate cost efficiency\r\n  calculateCostEfficiency(totalCost, numLocations) {\r\n    const costPerLocation = totalCost / numLocations;\r\n    return costPerLocation < 5000 ? 'High' : costPerLocation < 8000 ? 'Medium' : 'Low';\r\n  }\r\n}"],"mappings":"AAAA;AACA;;AAEA,OAAO,MAAMA,yBAAyB,CAAC;EACrCC,WAAWA,CAACC,SAAS,EAAEC,MAAM,EAAE;IAC7B,IAAI,CAACD,SAAS,GAAGA,SAAS,IAAI,EAAE;IAChC,IAAI,CAACC,MAAM,GAAGA,MAAM,IAAI,EAAE;;IAE1B;IACA,IAAI,CAACC,kBAAkB,GAAG;MACxB,OAAO,EAAE;QACP,QAAQ,EAAE,GAAG;QAAE,MAAM,EAAE,GAAG;QAAE,UAAU,EAAE,GAAG;QAAE,UAAU,EAAE,GAAG;QAC5D,OAAO,EAAE,IAAI;QAAE,SAAS,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,WAAW,EAAE;MAChE,CAAC;MACD,QAAQ,EAAE;QACR,OAAO,EAAE,GAAG;QAAE,SAAS,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,QAAQ,EAAE;MAC5D,CAAC;MACD,WAAW,EAAE;QACX,OAAO,EAAE,GAAG;QAAE,QAAQ,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,UAAU,EAAE;MAC7D,CAAC;MACD,UAAU,EAAE;QACV,OAAO,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,SAAS,EAAE,GAAG;QAChE,MAAM,EAAE;MACV,CAAC;MACD,WAAW,EAAE;QACX,UAAU,EAAE,GAAG;QAAE,OAAO,EAAE,IAAI;QAAE,SAAS,EAAE,GAAG;QAAE,OAAO,EAAE;MAC3D,CAAC;MACD,OAAO,EAAE;QACP,OAAO,EAAE,IAAI;QAAE,SAAS,EAAE;MAC5B,CAAC;MACD,SAAS,EAAE;QACT,OAAO,EAAE,GAAG;QAAE,SAAS,EAAE,GAAG;QAAE,WAAW,EAAE,GAAG;QAAE,OAAO,EAAE;MAC3D,CAAC;MACD,UAAU,EAAE;QACV,OAAO,EAAE,GAAG;QAAE,YAAY,EAAE,GAAG;QAAE,QAAQ,EAAE;MAC7C,CAAC;MACD,SAAS,EAAE;QACT,QAAQ,EAAE,GAAG;QAAE,OAAO,EAAE,GAAG;QAAE,QAAQ,EAAE,GAAG;QAAE,QAAQ,EAAE;MACxD,CAAC;MACD,QAAQ,EAAE;QACR,aAAa,EAAE,EAAE;QAAE,SAAS,EAAE,GAAG;QAAE,OAAO,EAAE;MAC9C,CAAC;MACD,QAAQ,EAAE;QACR,QAAQ,EAAE,EAAE;QAAE,QAAQ,EAAE,GAAG;QAAE,MAAM,EAAE,GAAG;QAAE,SAAS,EAAE;MACvD,CAAC;MACD,QAAQ,EAAE;QACR,QAAQ,EAAE,EAAE;QAAE,QAAQ,EAAE,GAAG;QAAE,MAAM,EAAE;MACvC;IACF,CAAC;;IAED;IACA,IAAI,CAACC,mBAAmB,GAAG;MACzB,QAAQ,EAAE,GAAG;MACb,OAAO,EAAE,IAAI;MACb,KAAK,EAAE,IAAI;MACX,KAAK,EAAE;IACT,CAAC;;IAED;IACA,IAAI,CAACC,kBAAkB,GAAG;MACxB,OAAO,EAAE;QAAEC,GAAG,EAAE,IAAI;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAChD,QAAQ,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAChD,WAAW,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MACnD,UAAU,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAClD,UAAU,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAClD,SAAS,EAAE;QAAEF,GAAG,EAAE,IAAI;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAClD,OAAO,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAC/C,SAAS,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MACjD,WAAW,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MACnD,QAAQ,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAChD,eAAe,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MACvD,QAAQ,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAChD,QAAQ,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK,CAAC;MAChD,WAAW,EAAE;QAAEF,GAAG,EAAE,GAAG;QAAEC,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAK;IACpD,CAAC;;IAED;IACA,IAAI,CAACC,YAAY,GAAG;MAClB,QAAQ,EAAE;QACRC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;QAClDC,WAAW,EAAE,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,CAAC;QAClDC,WAAW,EAAE;UAAEC,GAAG,EAAE,EAAE;UAAEC,GAAG,EAAE;QAAG,CAAC;QACjCC,QAAQ,EAAE;MACZ,CAAC;MACD,QAAQ,EAAE;QACRL,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;QAC7BC,WAAW,EAAE,CAAC,OAAO,EAAE,YAAY,CAAC;QACpCK,YAAY,EAAE,CAAC,WAAW,EAAE,SAAS,CAAC;QACtCJ,WAAW,EAAE;UAAEC,GAAG,EAAE,EAAE;UAAEC,GAAG,EAAE;QAAG,CAAC;QACjCC,QAAQ,EAAE;MACZ,CAAC;MACD,SAAS,EAAE;QACTL,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;QAC7BC,WAAW,EAAE,CAAC,eAAe,EAAE,OAAO,CAAC;QACvCC,WAAW,EAAE;UAAEC,GAAG,EAAE,EAAE;UAAEC,GAAG,EAAE;QAAG,CAAC;QACjCC,QAAQ,EAAE;MACZ;IACF,CAAC;EACH;;EAEA;EACAE,wBAAwBA,CAACC,WAAW,EAAE;IACpCC,OAAO,CAACC,GAAG,CAAC,iDAAiD,EAAEF,WAAW,CAAC;IAE3E,MAAM;MACJG,SAAS,GAAG,EAAE;MACdC,eAAe,GAAG,CAAC;MACnBC,YAAY,GAAG,QAAQ;MACvBC,cAAc,GAAG,IAAI;MACrBC,cAAc,GAAG,KAAK;MACtBC,eAAe,GAAG;IACpB,CAAC,GAAGR,WAAW;;IAEf;IACA,IAAIS,kBAAkB,GAAG,IAAI,CAACC,0BAA0B,CAACP,SAAS,CAAC;IACnEF,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAEO,kBAAkB,CAACE,MAAM,CAAC;IAEpE,IAAIF,kBAAkB,CAACE,MAAM,KAAK,CAAC,EAAE;MACnC,MAAM,IAAIC,KAAK,CAAC,4CAA4C,CAAC;IAC/D;;IAEA;IACA,IAAIN,cAAc,IAAIE,eAAe,EAAE;MACrCC,kBAAkB,GAAG,IAAI,CAACI,yBAAyB,CAACJ,kBAAkB,EAAEH,cAAc,EAAEE,eAAe,CAAC;MACxGP,OAAO,CAACC,GAAG,CAAC,oBAAoBM,eAAe,KAAK,EAAEC,kBAAkB,CAACE,MAAM,CAAC;MAEhF,IAAIF,kBAAkB,CAACE,MAAM,KAAK,CAAC,EAAE;QACnC,MAAM,IAAIC,KAAK,CAAC,6BAA6BJ,eAAe,+DAA+D,CAAC;MAC9H;IACF;;IAEA;IACA,MAAMM,aAAa,GAAG,IAAI,CAACC,YAAY,CAACN,kBAAkB,EAAEH,cAAc,EAAEF,eAAe,EAAEI,eAAe,CAAC;IAC7GP,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEY,aAAa,CAACH,MAAM,EAAE,WAAW,CAAC;IAEzE,IAAIG,aAAa,CAACH,MAAM,KAAK,CAAC,EAAE;MAC9B,MAAM,IAAIC,KAAK,CAAC,0DAA0D,CAAC;IAC7E;;IAEA;IACA,MAAMI,iBAAiB,GAAG,IAAI,CAACC,uBAAuB,CAACH,aAAa,EAAEP,cAAc,EAAEF,YAAY,CAAC;IAEnG,OAAOW,iBAAiB;EAC1B;;EAEA;EACAN,0BAA0BA,CAACP,SAAS,EAAE;IACpC,IAAI,CAACA,SAAS,IAAIA,SAAS,CAACQ,MAAM,KAAK,CAAC,EAAE;MACxC,OAAO,IAAI,CAAC5B,SAAS,CAACmC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACrC;IAEA,MAAMC,iBAAiB,GAAG,IAAI,CAACpC,SAAS,CAACqC,MAAM,CAACC,QAAQ,IAAI;MAC1D,MAAMC,YAAY,GAAGD,QAAQ,CAACE,IAAI,IAAI,EAAE;MACxC,MAAMC,gBAAgB,GAAGH,QAAQ,CAACI,QAAQ,IAAI,EAAE;MAChD,MAAMC,mBAAmB,GAAGL,QAAQ,CAACM,WAAW,IAAI,EAAE;MAEtD,OAAOxB,SAAS,CAACyB,IAAI,CAACC,QAAQ,IAAI;QAChC,OAAOP,YAAY,CAACM,IAAI,CAACE,GAAG,IAAIA,GAAG,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACH,QAAQ,CAACE,WAAW,CAAC,CAAC,CAAC,CAAC,IAC5EP,gBAAgB,CAACO,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACH,QAAQ,CAACE,WAAW,CAAC,CAAC,CAAC,IAC/DL,mBAAmB,CAACK,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACH,QAAQ,CAACE,WAAW,CAAC,CAAC,CAAC;MAC3E,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF;IACA,IAAIZ,iBAAiB,CAACR,MAAM,GAAG,CAAC,EAAE;MAChC,MAAMsB,mBAAmB,GAAG,IAAI,CAAClD,SAAS,CAACqC,MAAM,CAACc,GAAG,IACnD,CAAC,WAAW,EAAE,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,OAAO,CAAC,CAACF,QAAQ,CAACE,GAAG,CAACC,EAAE,CACvE,CAAC;MACD,OAAO,CAAC,GAAGhB,iBAAiB,EAAE,GAAGc,mBAAmB,CAAC,CAACf,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;IACnE;IAEA,OAAOC,iBAAiB,CAACD,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EACvC;;EAEA;EACAL,yBAAyBA,CAAC9B,SAAS,EAAEqD,aAAa,EAAEC,aAAa,EAAE;IACjE,IAAI,CAACD,aAAa,IAAI,CAACC,aAAa,EAAE;MACpC,OAAOtD,SAAS;IAClB;IAEA,MAAMuD,QAAQ,GAAGvD,SAAS,CAACqC,MAAM,CAACC,QAAQ,IAAI;MAC5C,MAAMkB,cAAc,GAAG,IAAI,CAACC,sBAAsB,CAACnB,QAAQ,CAAC;MAC5D,MAAMoB,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAACN,aAAa,EAAEG,cAAc,CAAC;MAE/EtC,OAAO,CAACC,GAAG,CAAC,0BAA0BmB,QAAQ,CAACsB,IAAI,KAAKF,QAAQ,YAAYJ,aAAa,KAAK,CAAC;MAE/F,OAAOI,QAAQ,IAAIJ,aAAa;IAClC,CAAC,CAAC;IAEF,OAAOC,QAAQ;EACjB;;EAEA;EACAvB,YAAYA,CAAChC,SAAS,EAAEqD,aAAa,EAAEQ,OAAO,EAAEP,aAAa,GAAG,IAAI,EAAE;IACpE,IAAI,CAACtD,SAAS,IAAIA,SAAS,CAAC4B,MAAM,KAAK,CAAC,EAAE;MACxC,OAAO,EAAE;IACX;;IAEA;IACA,MAAMkC,YAAY,GAAGC,IAAI,CAACnD,GAAG,CAACZ,SAAS,CAAC4B,MAAM,EAAEmC,IAAI,CAACC,IAAI,CAACH,OAAO,GAAG,GAAG,CAAC,CAAC;IACzE,MAAMI,gBAAgB,GAAGjE,SAAS,CAACmC,KAAK,CAAC,CAAC,EAAE2B,YAAY,CAAC;IAEzD,IAAIG,gBAAgB,CAACrC,MAAM,IAAI,CAAC,EAAE;MAChC,OAAOqC,gBAAgB;IACzB;;IAEA;IACA,MAAMlC,aAAa,GAAG,EAAE;IACxB,MAAMmC,kBAAkB,GAAG,CAAC,GAAGD,gBAAgB,CAAC;;IAEhD;IACA,IAAIE,eAAe;IACnB,IAAId,aAAa,EAAE;MACjBc,eAAe,GAAG,IAAI,CAACC,mBAAmB,CAACF,kBAAkB,EAAEb,aAAa,CAAC;IAC/E,CAAC,MAAM;MACLc,eAAe,GAAGD,kBAAkB,CAAC,CAAC,CAAC;IACzC;IAEAnC,aAAa,CAACsC,IAAI,CAACF,eAAe,CAAC;IACnC,MAAMG,YAAY,GAAGJ,kBAAkB,CAACK,OAAO,CAACJ,eAAe,CAAC;IAChED,kBAAkB,CAACM,MAAM,CAACF,YAAY,EAAE,CAAC,CAAC;;IAE1C;IACA,OAAOJ,kBAAkB,CAACtC,MAAM,GAAG,CAAC,IAAIG,aAAa,CAACH,MAAM,GAAGkC,YAAY,EAAE;MAC3E,MAAMW,aAAa,GAAG,IAAI,CAAChB,sBAAsB,CAACU,eAAe,CAAC;MAClE,IAAIO,eAAe,GAAG,IAAI;MAC1B,IAAIC,gBAAgB,GAAGC,QAAQ;MAE/BV,kBAAkB,CAACW,OAAO,CAAC1B,GAAG,IAAI;QAChC,MAAM2B,SAAS,GAAG,IAAI,CAACrB,sBAAsB,CAACN,GAAG,CAAC;QAClD,MAAMO,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAACc,aAAa,EAAEK,SAAS,CAAC;;QAE1E;QACA,IAAIxB,aAAa,IAAID,aAAa,EAAE;UAClC,MAAM0B,iBAAiB,GAAG,IAAI,CAACpB,0BAA0B,CAACN,aAAa,EAAEyB,SAAS,CAAC;UACnF,IAAIC,iBAAiB,GAAGzB,aAAa,EAAE;YACrC,OAAO,CAAC;UACV;QACF;QAEA,IAAII,QAAQ,GAAGiB,gBAAgB,EAAE;UAC/BA,gBAAgB,GAAGjB,QAAQ;UAC3BgB,eAAe,GAAGvB,GAAG;QACvB;MACF,CAAC,CAAC;MAEF,IAAIuB,eAAe,EAAE;QACnB3C,aAAa,CAACsC,IAAI,CAACK,eAAe,CAAC;QACnCP,eAAe,GAAGO,eAAe;QACjC,MAAMM,YAAY,GAAGd,kBAAkB,CAACK,OAAO,CAACG,eAAe,CAAC;QAChER,kBAAkB,CAACM,MAAM,CAACQ,YAAY,EAAE,CAAC,CAAC;MAC5C,CAAC,MAAM;QACL;MACF;IACF;IAEA,OAAOjD,aAAa;EACtB;;EAEA;EACAqC,mBAAmBA,CAACpE,SAAS,EAAEiF,KAAK,EAAE;IACpC,IAAIC,OAAO,GAAGlF,SAAS,CAAC,CAAC,CAAC;IAC1B,IAAI2E,gBAAgB,GAAGC,QAAQ;IAE/B5E,SAAS,CAAC6E,OAAO,CAACvC,QAAQ,IAAI;MAC5B,MAAMwC,SAAS,GAAG,IAAI,CAACrB,sBAAsB,CAACnB,QAAQ,CAAC;MACvD,MAAMoB,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAACsB,KAAK,EAAEH,SAAS,CAAC;MAElE,IAAIpB,QAAQ,GAAGiB,gBAAgB,EAAE;QAC/BA,gBAAgB,GAAGjB,QAAQ;QAC3BwB,OAAO,GAAG5C,QAAQ;MACpB;IACF,CAAC,CAAC;IAEF,OAAO4C,OAAO;EAChB;;EAEA;EACAzB,sBAAsBA,CAACnB,QAAQ,EAAE;IAC/B,IAAIA,QAAQ,CAAC6C,WAAW,EAAE;MACxB,IAAI,OAAO7C,QAAQ,CAAC6C,WAAW,KAAK,QAAQ,IAAI7C,QAAQ,CAAC6C,WAAW,CAACC,GAAG,EAAE;QACxE,OAAO;UAAEA,GAAG,EAAE9C,QAAQ,CAAC6C,WAAW,CAACC,GAAG;UAAEC,GAAG,EAAE/C,QAAQ,CAAC6C,WAAW,CAACE;QAAI,CAAC;MACzE,CAAC,MAAM,IAAIC,KAAK,CAACC,OAAO,CAACjD,QAAQ,CAAC6C,WAAW,CAAC,EAAE;QAC9C,OAAO;UAAEC,GAAG,EAAE9C,QAAQ,CAAC6C,WAAW,CAAC,CAAC,CAAC;UAAEE,GAAG,EAAE/C,QAAQ,CAAC6C,WAAW,CAAC,CAAC;QAAE,CAAC;MACvE;IACF;;IAEA;IACA,OAAO;MAAEC,GAAG,EAAE,OAAO;MAAEC,GAAG,EAAE;IAAQ,CAAC,CAAC,CAAC;EACzC;;EAEA;EACA1B,0BAA0BA,CAAC6B,MAAM,EAAEC,MAAM,EAAE;IACzC,MAAMC,CAAC,GAAG,IAAI,CAAC,CAAC;IAChB,MAAMC,IAAI,GAAGH,MAAM,CAACJ,GAAG,IAAII,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IACzC,MAAMI,IAAI,GAAGJ,MAAM,CAACH,GAAG,IAAIG,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IACzC,MAAMK,IAAI,GAAGJ,MAAM,CAACL,GAAG,IAAIK,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IACzC,MAAMK,IAAI,GAAGL,MAAM,CAACJ,GAAG,IAAII,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IAEzC,MAAMM,IAAI,GAAG,CAACF,IAAI,GAAGF,IAAI,IAAI5B,IAAI,CAACiC,EAAE,GAAG,GAAG;IAC1C,MAAMC,IAAI,GAAG,CAACH,IAAI,GAAGF,IAAI,IAAI7B,IAAI,CAACiC,EAAE,GAAG,GAAG;IAE1C,MAAME,CAAC,GAAGnC,IAAI,CAACoC,GAAG,CAACJ,IAAI,GAAC,CAAC,CAAC,GAAGhC,IAAI,CAACoC,GAAG,CAACJ,IAAI,GAAC,CAAC,CAAC,GACnChC,IAAI,CAACqC,GAAG,CAACT,IAAI,GAAG5B,IAAI,CAACiC,EAAE,GAAG,GAAG,CAAC,GAAGjC,IAAI,CAACqC,GAAG,CAACP,IAAI,GAAG9B,IAAI,CAACiC,EAAE,GAAG,GAAG,CAAC,GAC/DjC,IAAI,CAACoC,GAAG,CAACF,IAAI,GAAC,CAAC,CAAC,GAAGlC,IAAI,CAACoC,GAAG,CAACF,IAAI,GAAC,CAAC,CAAC;IAE7C,MAAMI,CAAC,GAAG,CAAC,GAAGtC,IAAI,CAACuC,KAAK,CAACvC,IAAI,CAACwC,IAAI,CAACL,CAAC,CAAC,EAAEnC,IAAI,CAACwC,IAAI,CAAC,CAAC,GAACL,CAAC,CAAC,CAAC;IACtD,OAAOnC,IAAI,CAACyC,KAAK,CAACd,CAAC,GAAGW,CAAC,CAAC;EAC1B;;EAEA;EACAnE,uBAAuBA,CAACuE,IAAI,EAAEC,aAAa,EAAEC,MAAM,EAAE;IACnD,MAAMC,SAAS,GAAG,EAAE;IACpB,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAIC,SAAS,GAAG,CAAC;IAEjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,IAAI,CAAC7E,MAAM,EAAEmF,CAAC,EAAE,EAAE;MACpC,MAAMzE,QAAQ,GAAGmE,IAAI,CAACM,CAAC,CAAC;MACxB,MAAMC,YAAY,GAAGP,IAAI,CAACM,CAAC,GAAG,CAAC,CAAC;;MAEhC;MACA,MAAME,cAAc,GAAG,IAAI,CAACC,wBAAwB,CAAC5E,QAAQ,CAAC;MAC9D,MAAM6E,SAAS,GAAG,IAAI,CAACC,oBAAoB,CAAC9E,QAAQ,CAACc,EAAE,IAAId,QAAQ,CAACsB,IAAI,EAAE+C,MAAM,CAAC,GAChE,IAAI,CAACU,WAAW,CAACV,MAAM,CAAC,GACxB,IAAI,CAACW,qBAAqB,CAAC,CAAC;MAE7C,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGN,cAAc,EAAEM,GAAG,EAAE,EAAE;QAC7C,MAAMC,WAAW,GAAG,IAAI,CAACC,mBAAmB,CAACnF,QAAQ,EAAEiF,GAAG,EAAEZ,MAAM,CAAC;QACnEC,SAAS,CAACvC,IAAI,CAAC;UACbkD,GAAG,EAAEV,UAAU,GAAGU,GAAG;UACrBjF,QAAQ,EAAEA,QAAQ,CAACsB,IAAI;UACvB8D,IAAI,EAAE,aAAa;UACnB9E,WAAW,EAAE4E,WAAW,CAAC5E,WAAW;UACpC+E,UAAU,EAAEH,WAAW,CAACG,UAAU;UAClCC,KAAK,EAAE;YACLC,aAAa,EAAE,IAAI,CAACT,oBAAoB,CAAC9E,QAAQ,CAACc,EAAE,IAAId,QAAQ,CAACsB,IAAI,EAAE+C,MAAM,CAAC;YAC9EmB,IAAI,EAAE,IAAI,CAACT,WAAW,CAACV,MAAM,CAAC;YAC9BoB,cAAc,EAAE,IAAI,CAACT,qBAAqB,CAAC,CAAC;YAC5CU,WAAW,EAAER,WAAW,CAACS,eAAe;YACxCC,KAAK,EAAEf,SAAS,GAAGK,WAAW,CAACS;UACjC,CAAC;UACDE,gBAAgB,EAAE,IAAI,CAACC,mBAAmB,CAAC9F,QAAQ,CAAC;UACpD+F,aAAa,EAAE,IAAI,CAACC,gBAAgB,CAAChG,QAAQ;QAC/C,CAAC,CAAC;QACFwE,SAAS,IAAIK,SAAS,GAAGK,WAAW,CAACS,eAAe;MACtD;MAEApB,UAAU,IAAII,cAAc;;MAE5B;MACA,IAAID,YAAY,EAAE;QAChB,MAAMuB,aAAa,GAAG,IAAI,CAACC,wBAAwB,CAAClG,QAAQ,EAAE0E,YAAY,EAAEN,aAAa,CAAC;QAC1FE,SAAS,CAACvC,IAAI,CAAC;UACbkD,GAAG,EAAEV,UAAU;UACfvE,QAAQ,EAAE,GAAGA,QAAQ,CAACsB,IAAI,OAAOoD,YAAY,CAACpD,IAAI,EAAE;UACpD8D,IAAI,EAAE,QAAQ;UACd9E,WAAW,EAAE,eAAeN,QAAQ,CAACsB,IAAI,OAAOoD,YAAY,CAACpD,IAAI,QAAQ2E,aAAa,CAACE,IAAI,EAAE;UAC7FF,aAAa,EAAEA,aAAa;UAC5BX,KAAK,EAAE;YACLc,SAAS,EAAEH,aAAa,CAACI,IAAI;YAC7Bb,IAAI,EAAES,aAAa,CAACK,QAAQ,IAAI,CAAC;YACjCV,KAAK,EAAEK,aAAa,CAACI,IAAI,IAAIJ,aAAa,CAACK,QAAQ,IAAI,CAAC;UAC1D;QACF,CAAC,CAAC;QACF9B,SAAS,IAAIyB,aAAa,CAACI,IAAI,IAAIJ,aAAa,CAACK,QAAQ,IAAI,CAAC,CAAC;QAC/D/B,UAAU,EAAE;MACd;IACF;IAEA,OAAO;MACLzD,EAAE,EAAE,kBAAkByF,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MAClClF,IAAI,EAAE,mCAAmC;MACzChB,WAAW,EAAE,4BAA4B6D,IAAI,CAAC7E,MAAM,wCAAwC;MAC5FmH,KAAK,EAAE,SAAS;MAChBtC,IAAI,EAAEA,IAAI,CAACuC,GAAG,CAAC7F,GAAG,IAAI;QACpB,MAAM8F,MAAM,GAAG,IAAI,CAACxF,sBAAsB,CAACN,GAAG,CAAC;QAC/C,OAAO,CAAC8F,MAAM,CAAC7D,GAAG,EAAE6D,MAAM,CAAC5D,GAAG,CAAC;MACjC,CAAC,CAAC;MACFrF,SAAS,EAAEyG,IAAI,CAACuC,GAAG,CAAC7F,GAAG,IAAI;QACzB,MAAM8F,MAAM,GAAG,IAAI,CAACxF,sBAAsB,CAACN,GAAG,CAAC;QAC/C,OAAO;UACLS,IAAI,EAAET,GAAG,CAACS,IAAI;UACduB,WAAW,EAAE,CAAC8D,MAAM,CAAC7D,GAAG,EAAE6D,MAAM,CAAC5D,GAAG,CAAC;UACrCzC,WAAW,EAAEO,GAAG,CAACP,WAAW,IAAI;QAClC,CAAC;MACH,CAAC,CAAC;MACFX,iBAAiB,EAAE2E,SAAS;MAC5BE,SAAS,EAAE/C,IAAI,CAACyC,KAAK,CAACM,SAAS,CAAC;MAChCoC,SAAS,EAAErC,UAAU,GAAG,CAAC;MACzBsC,cAAc,EAAE,IAAI,CAACC,qBAAqB,CAAC3C,IAAI,CAAC;MAChD4C,mBAAmB,EAAE;QACnBC,aAAa,EAAE,IAAI,CAACC,sBAAsB,CAAC9C,IAAI,CAAC;QAChD+C,iBAAiB,EAAE,IAAI,CAACC,0BAA0B,CAAChD,IAAI,CAAC;QACxDiD,cAAc,EAAE,IAAI,CAACC,uBAAuB,CAAC7C,SAAS,EAAEL,IAAI,CAAC7E,MAAM;MACrE;IACF,CAAC;EACH;;EAEA;EACAsF,wBAAwBA,CAAC5E,QAAQ,EAAE;IAAA,IAAAsH,cAAA;IACjC;IACA,MAAMC,YAAY,GAAG,EAAAD,cAAA,GAAAtH,QAAQ,CAACsB,IAAI,cAAAgG,cAAA,uBAAbA,cAAA,CAAe5G,WAAW,CAAC,CAAC,KAAI,EAAE;;IAEvD;IACA,MAAM8G,iBAAiB,GAAG,CAAC,OAAO,EAAE,WAAW,EAAE,WAAW,EAAE,UAAU,EAAE,OAAO,CAAC;IAClF,IAAIA,iBAAiB,CAACjH,IAAI,CAACkH,IAAI,IAAIF,YAAY,CAAC5G,QAAQ,CAAC8G,IAAI,CAAC,CAAC,EAAE;MAC/D,OAAO,CAAC;IACV;;IAEA;IACA,MAAMC,YAAY,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,WAAW,EAAE,QAAQ,CAAC;IAChE,IAAIA,YAAY,CAACnH,IAAI,CAACoH,IAAI,IAAIJ,YAAY,CAAC5G,QAAQ,CAACgH,IAAI,CAAC,CAAC,EAAE;MAC1D,OAAO,CAAC;IACV;;IAEA;IACA,OAAO,CAAC;EACV;;EAEA;EACA7C,oBAAoBA,CAAC8C,UAAU,EAAEvD,MAAM,EAAE;IACvC,MAAMwD,YAAY,GAAG,CAAAD,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAElH,WAAW,CAAC,CAAC,CAACoH,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,KAAI,SAAS;IAChF,MAAMxC,KAAK,GAAG,IAAI,CAACxH,kBAAkB,CAAC+J,YAAY,CAAC,IAAI;MAAE9J,GAAG,EAAE,GAAG;MAAEC,MAAM,EAAE,IAAI;MAAEC,IAAI,EAAE;IAAK,CAAC;IAC7F,OAAOqH,KAAK,CAACjB,MAAM,CAAC,IAAIiB,KAAK,CAACtH,MAAM;EACtC;EAEA+G,WAAWA,CAACV,MAAM,EAAE;IAClB,MAAM0D,SAAS,GAAG;MAAEhK,GAAG,EAAE,GAAG;MAAEC,MAAM,EAAE,IAAI;MAAEC,IAAI,EAAE;IAAK,CAAC;IACxD,OAAO8J,SAAS,CAAC1D,MAAM,CAAC,IAAI0D,SAAS,CAAC/J,MAAM;EAC9C;EAEAgH,qBAAqBA,CAAA,EAAG;IACtB,OAAO,GAAG,CAAC,CAAC;EACd;;EAEA;EACAG,mBAAmBA,CAACnF,QAAQ,EAAEgI,SAAS,EAAE3D,MAAM,EAAE;IAC/C,MAAMqB,WAAW,GAAG,IAAI,CAACuC,sBAAsB,CAACjI,QAAQ,CAACc,EAAE,IAAId,QAAQ,CAACsB,IAAI,CAAC;IAC7E,MAAM4G,mBAAmB,GAAGxC,WAAW,CAAC7F,KAAK,CAACmI,SAAS,GAAG,CAAC,EAAE,CAACA,SAAS,GAAG,CAAC,IAAI,CAAC,CAAC;IAEjF,OAAO;MACL1H,WAAW,EAAE,OAAO0H,SAAS,GAAG,CAAC,OAAOhI,QAAQ,CAACsB,IAAI,KAAK4G,mBAAmB,CAACxB,GAAG,CAAC9C,CAAC,IAAIA,CAAC,CAACtC,IAAI,CAAC,CAAC6G,IAAI,CAAC,IAAI,CAAC,EAAE;MAC3G9C,UAAU,EAAE6C,mBAAmB;MAC/BvC,eAAe,EAAEuC,mBAAmB,CAACE,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAKD,GAAG,IAAIC,IAAI,CAACC,SAAS,IAAI,CAAC,CAAC,EAAE,CAAC;IAC3F,CAAC;EACH;;EAEA;EACAN,sBAAsBA,CAACL,UAAU,EAAE;IACjC,MAAMlC,WAAW,GAAG;MAClB,OAAO,EAAE,CACP;QAAEpE,IAAI,EAAE,UAAU;QAAEiH,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACpD;QAAElH,IAAI,EAAE,YAAY;QAAEiH,SAAS,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAS,CAAC,EACpD;QAAElH,IAAI,EAAE,aAAa;QAAEiH,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACvD;QAAElH,IAAI,EAAE,cAAc;QAAEiH,SAAS,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAS,CAAC,CACvD;MACD,WAAW,EAAE,CACX;QAAElH,IAAI,EAAE,WAAW;QAAEiH,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACrD;QAAElH,IAAI,EAAE,WAAW;QAAEiH,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACrD;QAAElH,IAAI,EAAE,aAAa;QAAEiH,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,CACxD;MACD,QAAQ,EAAE,CACR;QAAElH,IAAI,EAAE,YAAY;QAAEiH,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACtD;QAAElH,IAAI,EAAE,aAAa;QAAEiH,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAU,CAAC,EACvD;QAAElH,IAAI,EAAE,YAAY;QAAEiH,SAAS,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAS,CAAC;IAEzD,CAAC;IAED,MAAMX,YAAY,GAAG,CAAAD,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAElH,WAAW,CAAC,CAAC,CAACoH,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,KAAI,SAAS;IAChF,OAAOpC,WAAW,CAACmC,YAAY,CAAC,IAAI,CAClC;MAAEvG,IAAI,EAAE,iBAAiB;MAAEiH,SAAS,EAAE,EAAE;MAAEC,IAAI,EAAE;IAAU,CAAC,EAC3D;MAAElH,IAAI,EAAE,cAAc;MAAEiH,SAAS,EAAE,EAAE;MAAEC,IAAI,EAAE;IAAU,CAAC,EACxD;MAAElH,IAAI,EAAE,eAAe;MAAEiH,SAAS,EAAE,EAAE;MAAEC,IAAI,EAAE;IAAU,CAAC,CAC1D;EACH;;EAEA;EACAtC,wBAAwBA,CAACuC,IAAI,EAAEC,EAAE,EAAEvC,IAAI,EAAE;IACvC,MAAMwC,UAAU,GAAG,IAAI,CAACxH,sBAAsB,CAACsH,IAAI,CAAC;IACpD,MAAMG,QAAQ,GAAG,IAAI,CAACzH,sBAAsB,CAACuH,EAAE,CAAC;IAChD,MAAMtH,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAACsH,UAAU,EAAEC,QAAQ,CAAC;IAEtE,MAAMxE,aAAa,GAAG+B,IAAI,IAAI,KAAK;IACnC,MAAM0C,SAAS,GAAG,IAAI,CAAChL,mBAAmB,CAACuG,aAAa,CAAC,IAAI,IAAI,CAACvG,mBAAmB,CAACiL,GAAG;IACzF,MAAMC,QAAQ,GAAG3H,QAAQ,GAAGyH,SAAS;;IAErC;IACA,MAAMG,MAAM,GAAG;MAAEF,GAAG,EAAE,EAAE;MAAEG,KAAK,EAAE,EAAE;MAAEC,GAAG,EAAE,EAAE;MAAEC,MAAM,EAAE;IAAI,CAAC,CAAC,CAAC;IAC7D,MAAMC,KAAK,GAAGJ,MAAM,CAAC5E,aAAa,CAAC,IAAI4E,MAAM,CAACF,GAAG;IACjD,MAAMO,eAAe,GAAG5H,IAAI,CAACC,IAAI,CAACN,QAAQ,GAAGgI,KAAK,CAAC;IAEnD,OAAO;MACLjD,IAAI,EAAE/B,aAAa;MACnBhD,QAAQ,EAAEA,QAAQ;MAClBkI,QAAQ,EAAE,GAAGD,eAAe,QAAQ;MACpChD,IAAI,EAAE5E,IAAI,CAACyC,KAAK,CAAC6E,QAAQ,CAAC;MAC1BzC,QAAQ,EAAE+C,eAAe,GAAG,CAAC,GAAG,GAAG,GAAG;IACxC,CAAC;EACH;;EAEA;EACAvD,mBAAmBA,CAAC9F,QAAQ,EAAE;IAC5B,OAAO,CACL,8CAA8C,EAC9C,iCAAiCA,QAAQ,CAACuJ,OAAO,IAAI,UAAU,QAAQ,EACvE,8CAA8C,CAC/C;EACH;;EAEA;EACAvD,gBAAgBA,CAAChG,QAAQ,EAAE;IACzB,OAAO,CACL,8CAA8C,EAC9C,uCAAuC,EACvC,uCAAuC,EACvC,2CAA2C,CAC5C;EACH;;EAEA;EACA8G,qBAAqBA,CAAC3C,IAAI,EAAE;IAC1B,MAAMqF,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;IACxBtF,IAAI,CAAC5B,OAAO,CAACvC,QAAQ,IAAI;MACvB,IAAIA,QAAQ,CAACuJ,OAAO,EAAEC,MAAM,CAACE,GAAG,CAAC1J,QAAQ,CAACuJ,OAAO,CAAC;MAClD,IAAIvJ,QAAQ,CAACI,QAAQ,EAAEoJ,MAAM,CAACE,GAAG,CAAC1J,QAAQ,CAACI,QAAQ,CAAC;MACpD,IAAIJ,QAAQ,CAACE,IAAI,EAAEF,QAAQ,CAACE,IAAI,CAACqC,OAAO,CAAC9B,GAAG,IAAI+I,MAAM,CAACE,GAAG,CAACjJ,GAAG,CAAC,CAAC;IAClE,CAAC,CAAC;IACF,OAAOuC,KAAK,CAACyF,IAAI,CAACe,MAAM,CAAC;EAC3B;;EAEA;EACAvC,sBAAsBA,CAAC9C,IAAI,EAAE;IAC3B,IAAI6C,aAAa,GAAG,CAAC;IACrB,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,IAAI,CAAC7E,MAAM,GAAG,CAAC,EAAEmF,CAAC,EAAE,EAAE;MACxC,MAAMkF,OAAO,GAAG,IAAI,CAACxI,sBAAsB,CAACgD,IAAI,CAACM,CAAC,CAAC,CAAC;MACpD,MAAMmF,IAAI,GAAG,IAAI,CAACzI,sBAAsB,CAACgD,IAAI,CAACM,CAAC,GAAG,CAAC,CAAC,CAAC;MACrDuC,aAAa,IAAI,IAAI,CAAC3F,0BAA0B,CAACsI,OAAO,EAAEC,IAAI,CAAC;IACjE;IACA,OAAO5C,aAAa;EACtB;;EAEA;EACAG,0BAA0BA,CAAChD,IAAI,EAAE;IAC/B,MAAMqF,MAAM,GAAG,IAAI,CAAC1C,qBAAqB,CAAC3C,IAAI,CAAC;IAC/C,OAAO1C,IAAI,CAACnD,GAAG,CAACkL,MAAM,CAAClK,MAAM,GAAG,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC;EAC5C;;EAEA;EACA+H,uBAAuBA,CAAC7C,SAAS,EAAEqF,YAAY,EAAE;IAC/C,MAAMC,eAAe,GAAGtF,SAAS,GAAGqF,YAAY;IAChD,OAAOC,eAAe,GAAG,IAAI,GAAG,MAAM,GAAGA,eAAe,GAAG,IAAI,GAAG,QAAQ,GAAG,KAAK;EACpF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}